535989ecb68da1affc531e866d190bfdbd9fc5fc,python/cpython,",bug",Programming,single,"even if those derived classes explictly accept those keyword arguments, the function return NULL",logic error,the bug occurred in mwassing the variable checking which may causing the returned value incorrect,Within function,return,Py_INCREF,"foreign, Py_INCREF ",memory management,c to py,Type Error,in if-statement which is checking the keyword argument type,Within function,Conditionals (predicate/conditional expression),needs to add corresponding logical conditions in the if statement,no,logical
44b054b84adc2deef45bf3fd2e17532d9a993cd3,python/cpython,",bug",Security,single,integer overflow,Data type error,"the bug occurred in a loop, which doing addition assignment",Within function,loop body,PyArg_ParseTuple,"foreign, PyArg_ParseTuple",Parsing arguments,py to c,Crash,the bug occurred in the variable initialization at the start of a function,Within function,assignment,needs to understand the usage of a variable that follows its declaration to identify incorrect initial type definitions.,no,data type
dac090d3e62cadd24fc6b73ab177bf98326c1849,python/cpython,",bug",Programming,single,"unpacking singleton tuples(1,) in list comprehensions and generator expressions (x for x, in ... ).",logic error,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,,"foreign, GeneratorExp",format handling,c to py,Data Corruption,"the bug occurred in a for-loop, which can unpack the singleton tuple",Within function,Conditionals (predicate/conditional expression),"The code runs without errors, but the output is not as expected.",yes,incorrect value
9b0ca79213f262daab54db21d6f3aa17b8dd86dd,python/cpython,",bug",Security,single," socket timeout exception will be caught correctly. Previously, the exception was not caught, since the status of the end of the socket is not judged by various if statements",unhandle exception,"a socket operation on a socket with a timeout,",Within function,return,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,DeadLock,the bug occurred after using the Poll/Select method checks the state of the Socket.,Within function,Conditionals (predicate/conditional expression),It is a challenge to determine if discerning the relationship between the n value and the occurrence of hang bugs.,no,error handling
7ec642a4d2ee98dfc0b67431255046374abc4ed7,python/cpython,",bug",Programming,single,"Since variable default to NULL, load files may fails.",logic error,"the bug occurred in find_module function, the argument default to NULL may cauing problem",Within function,Cross-language API call site,Py_XDECREF,"foreign, Py_XDECREF",memory management,c to py,Unexpected Behavior,the bug occurred after the value of the variable changed,Within function,API function,"The main challenge in detecting this bug is that it only manifests when using custom module loaders, which is not a common use case. Therefore, it might not be caught in routine testing. Additionally, the bug is in the module reloading mechanism, which is a complex part of the Python interpreter, making it harder to detect.",,
ea3912b0da71e16b8a37e04fcf3969dc85c27fa1,python/cpython,",bug",Security,single,recusion,recusion,the bug occurred in returning a incorrect value,Within function,return,Py_DECREF,"foreign, Py_DECREF",Exception Handling,c to py,Crash,the bug occurred after coercion in if-else statement.,Within function,API function,The infinite recursion can be hard to detect because it doesn't always manifest immediately. It might only occur with certain input values or in certain scenarios.,,
e27337b5d01a63f6874382175221936780e50acd,python/cpython,",bug",Security,single,integer overflow,unhandle exception,the bug occurred in returning a incorrect value,Within function,return,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Crash,adding a new function to check a variable range,Within function,if structure,It's difficult to determine whether it needs to verify the range of a variable after it's passed into a function.,,
33b730e33cb0a63f4030d1587a6196dcde36e965,python/cpython,",bug",Programming,single,def foo((x)): was getting recognized as requiring tuple unpacking which is not correct.,special case,"the bug occurred in if statement, which has not handle the complex arguments in function to unpacking it",Within function,True/false branch,PyErr_Format,"foreign, PyErr_Format",Exception Handling,c to py,Unexpected Behavior,the bug occurred in the type check switch-case.,Within function,if structure,Understanding the Python language specification and how tuple unpacking is supposed to work.,,
3a49e92d7dd7154a1f382ca1b28ffe610295147f,python/cpython,",bug",Security,single,missing error checking,compatibility,"the bug occurred in if statement, which has not handle the complex arguments in function to unpacking it",Within function,True/false branch,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Unexpected Behavior,after zeroMemory a pointer. the pointer get a value from getint().,Within function,API function,"The challenge in detecting this bug would be in identifying that the lack of error checking in the STARTUPINFO code was the cause of the issues. This would require a deep understanding of the Python C API and the Windows API, as well as the ability to debug C code. Additionally, the bug might only manifest itself under certain conditions when specific invalid values are passed in the STARTUPINFO structure, which could make it difficult to reproduce and identify.",,
95c1e5065ca572a4a3f602487ff6112f089a9257,python/cpython,",bug",Security,single,Null pointer reference,Null pointer reference,An initialized pointer will generate an error after getting the value from the function getInt().,Within function,Following a foreign function call,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Crash,the bug occurred after the varrible get a new value,Within function,API function,"The challenge in detecting this bug would be in identifying that the lack of memory allocation failure check was the cause of the crashes. This would require a deep understanding of the Python C API and memory management in C. Additionally, the bug might only manifest itself under memory pressure when memory allocation fails, which could make it difficult to reproduce and identify.",,
10402a306f613b37c96b51771e7ad0e1cf60a3a4,python/cpython,",bug",Programming,single,"append the object item at the end of list list. Return 0 if successful; return -1 and set an exception if unsuccessful. Missing checks for PyList_Append (result, line) return value, casuing error",return value error,"the bug occurred after PyLwast_Append, ",Within function,Cross-language API call site,"PyList_Append, Py_DECREF","foreign, PyList_Append, Py_DECREF, PyErr_Occurred","Exception Handling, Memory Management",c to py,Crash,"PyList_Append can return -1, which leading to error.",Within function,API function,The challenge in detecting this bug lies in the need to thoroughly check all possible error returns in the code. It requires a deep understanding of the code and the potential errors that could occur.,,
faa7648ffe6fbc568eeb6457815bd85cef21bfbd,python/cpython,",bug",Security,single,buffer overflow,buffer overflow,the function will return a incorrect value without the value checking,Within function,Conditional (predicate/conditional expression),PyObject_MALLOC,"foreign, PyObject_MALLOC",Memory Management,c to py,crash,"the bug occurred in the start of the function, the variable value get from the caller",Within function,assert,Detecting this kind of bug can be challenging because it requires a deep understanding of the function's expected inputs and behavior. Automated tools might not catch this if they don't have specific rules for argument checking in this context.,,
1fd00a1b7185a6bfb575e3ca0303e5fdc9d24498,python/cpython,",bug",Programming,single,"the string after the colon is used as the function name in error messages,fix the argument",error handling,"the bug occurred in PyArg_ParseTupleAndKeywords(), which not give complete error message",Within function,Cross-language API call site,PyArg_ParseTupleAndKeywords,"foreign, PyArg_ParseTupleAndKeywords",format handling,py to c,Unexpected Behavior,PyArg_ParseTupleAndKeywords() need use this argument,Within function,Conditionals (predicate/conditional expression),"the challenge in detecting this bug lies in the complexity of the Python import system and the various ways modules can be loaded. Understanding the nuances of how Python handles module loading and reloading, especially with custom loaders, requires deep knowledge of the Python language and its internals.",,
ea271f2d5e38129b45f798a9e883cdc1e47f8b31,python/cpython,",bug",Security,single,incorrect file access,Initialization,the bug occurred in variable initialization,Within function,Cross-language API call site,PyArg_ParseTuple,"foreign, PyArg_ParseTuple",format handling,py to c,crash,init the variable at the start of function,Within function,assignment,"the challenge in detecting such bugs lies in the fact that error messages and their formats can vary significantly across different languages. This requires a deep understanding of each language's error handling mechanisms and conventions. Furthermore, error messages are often overlooked during testing, as they are considered part of the ""negative path"". Therefore, they may not be as thoroughly tested as the main functionality of the code.",,
298c380c74294bedcc0b5999c57e3aca03fb3731,python/cpython,",bug",Programming,single,The shutil.move function in Python was not checking whether the destination directory was a subdirectory of the source directory. This led to the source directory being deleted if a user attempted to move it into one of its own subdirectories.,Data type error,the bug occurred in the time_t type variable convert to gmtime type.,Within function,Assignment,PyArg_ParseTuple,"foreign, PyArg_ParseTuple",format handling,py to c,Data Corruption,the bug occurred in using the variable,Within function,assignment,"The bug is relatively straightforward to detect if you are aware of the specific behavior of the shutil.move function. However, in a multi-language project, it could be challenging to detect if the bug is buried deep within the codebase or if the function is used infrequently. Additionally, the bug could be difficult to detect if the function's behavior aligns with the developer's expectations in most cases, leading to the erroneous behavior being overlooked.",,
3ecdb250afb74f77b1148dea2bf08775f9de2ab3,python/cpython,",bug",Security,single,Null pointer reference,Null pointer reference,the bug occurred in return a wrong value which was NULL,Within function,Following a foreign function call,Py_XINCREF,"foreign, PyErr_Format","Exception Handling, Memory Management",c to py,crash,"when the code need use __module__, but it is not here.",Within function,API function,"The challenge in detecting this bug lies in the fact that it only occurs under specific circumstances - when the type() function is used to create an object without explicitly setting the __module__ attribute. This is not a common use case and may not be covered by standard testing procedures. Additionally, the error message that is raised (SystemError: error return without exception set) is not very descriptive and does not clearly point to the root cause of the issue.",,
02c58f865c82021d1cde7064552d3a95301c8cc0,python/cpython,",bug",Programming,single,obj.__contains__() returns True/False instead of 1/0.,return value error,the bug occurred in return a wrong value which was int,Within function,Cross-language API call site,PyObject_IsTrue,"foreign, PyObject_IsTrue",format handling,c to py,Unexpected Behavior,The function creates a new bool variable and returns it at the end,Within function,API function,"The challenge in detecting this bug lies in the subtlety of the issue. In Python, 1/0 are equivalent to True/False, so the bug can not cause a noticeable problem in most cases. However, it could lead to unexpected behavior in certain scenarios where the strict type checking of True/False is required. As a multi-language project developer, understanding the nuances and conventions of each language is crucial for detecting such bugs.",,
62dba4c2775adfb5a5a97ca012a3ab00c4e28597,python/cpython,",bug",Programming,single,"The select module only allows lists, now accepts a sequence.",Data type error,the bug occurred in the function argument,Within function,Cross-language API call site,PySequence_Fast_GET_SIZE,"foreign, PySequence_Fast_GET_SIZE, Py_DECREF","format handling, memory management",c to py,Unexpected Behavior,all the list have to change to seq,Within function,API function,"The main challenge in detecting this bug is that it's not a traditional ""bug"" in the sense of causing a crash or incorrect behavior. Instead, it's a limitation in the function's design that reduces its flexibility and usability. This kind of issue can be harder to detect because it requires understanding the function's intended use cases and the types of data it should be able to handle. Additionally, in a multi-language project, different languages may have different conventions for handling collections of items, which can make it harder to design functions that are flexible and intuitive across different languages.",,
3646ab98af41f37eacf9cdc9d711327956b911f0,python/cpython,",bug",Security,single,"a wrong behavior from mark_save/restore(), which don't restore the mark_stack_base before restoring the marks.",stack overflow,"the bug occurred in the function mark_restore(), the mark_stack_base cannot restore correctly casuing error",Within function,Assignment,PyOS_CheckStack,"helper, PyOS_CheckStack",Objects,c to py,Crash,Add a new variable. changed mark_save/restore() to always restore the stackbase before restoring the marks.,Within function,assignment," the bug only manifests under certain conditions (specific regular expressions and input strings), making it harder to detect through general testing or usage.",,
be733ee7fb7e2779851368221639807938413e7c,python/cpython,",bug",Security,single,"logic error in computing variable lastindex, lastindex should return the the index of the matching group with the rightmost closing parenthesis",stack overflow,the bug occurred in the caculation formula of lastindex,Within function,Assignment,PyOS_CheckStack,"helper, PyOS_CheckStack",Objects,c to py,Unexpected Behavior,change the restore function,Within function,assignment,"the challenge in detecting this bug lies in the complexity of understanding the logic of the code and the expected behavior of the lastgroup method. It requires a deep understanding of the Python language and its regular expression handling. Additionally, the bug only manifests under specific conditions (i.e., when using certain regular expressions), which makes it harder to detect during routine testing.",,
8f24cdc0d5e30e2f924ed2e8a71400fa87a70983,python/cpython,",bug",Programming,single,"logic error, the loop can run correctly only in the first step, since a statement at outside of the loop which should in the loop.",logic error,"the bug occurred in the loop, when it run the second step",Within function,loop body,Py_INCREF,"foreign, Py_INCREF",memory management,c to py,Hang,"statement position get logic error, should move it into loop",Within function,Function call,"The challenge in detecting this bug lies in the specific conditions that need to be met for it to occur. It requires a timeout to be set on the socket and for not all bytes to be able to be sent immediately. This may not be a common scenario in all applications that use this function, making the bug harder to detect in regular usage. Additionally, the bug is in the logic of the function, which may not be immediately obvious without a deep understanding of how the function should work.",,
09705f0b89d8df6b40e10d8a91bee49a57b3b0d7,python/cpython,",bug",Programming,single,an empty Unicode string does not survive as Unicode after going through re.sub().,API misuse,the bug occurred at return position when the lwast size was zero,Within function,Cross-language API call site,PySequence_GetSlice,"foreign, PySequence_GetSlice",format handling,c to py,Type Error,at the return position in switch case,Within function,API function,"The bug only occurs with empty Unicode strings, which might not be a common use case. Additionally, the difference between a Unicode and non-Unicode string might not be immediately noticeable in many contexts, making the bug harder to detect.",,
7e23f00948a0157452c3a76ef1057fd494e48832,python/cpython,",bug",Security,single,integer overflow,integer overflow,"the bug occurred at varriable initialization, using a wrong type",Within function,return,PyInt_AsLong,"foreign, PyInt_AsLong",format handling,c to py,Type Error,at each wrong variable postion,Within function,API function,"The challenge in detecting this bug lies in the understanding of the correct data types and return values for the C functions used in the Python module. This requires knowledge of both Python and C, and the ability to correctly interpret the documentation for these functions.",,
8388895fe43da057006e50cae5d1b6e2a12083e0,python/cpython,",bug",Programming,single,cannot pass 'None' as the filename for the bsddb.*open functions,input checking,"the bug occurred at PyArg_ParseTuple(), which cannot parse None",Within function,Cross-language API call site,PyArg_ParseTuple,"foreign, PyArg_ParseTuple",Parsing arguments,py to c,Crash,"In if statement error, the function returned value as condition",Within function,API function,The challenge in detecting this bug lies in the specific use case where a NULL argument is passed to the dbopen() function. This is not a common scenario and might not be covered in standard testing,,
b6b8942f5302e76178833dc33596b892fef8f85f,python/cpython,",bug",Security,single,Null pointer reference,Null pointer reference,the bug occurred when the variable  = NULL and as a argument in a function,Within function,Cross-language API call site,PyErr_SetString,"foreign, PyErr_SetString","Exception Handling, Memory Management",c to py,Crash,"if statement error, logic error",Within function,API function,"From a multi-language project perspective, the challenge in detecting this bug lies in the understanding of the underlying library's (in this case, the Berkeley DB) capabilities and ensuring that the Python wrapper (bsddb module) correctly supports all these capabilities. This requires knowledge of both Python and the underlying library, which can be a challenge in a multi-language project.",,
cd637aae5665d40c405a173efd5d9f174e63bf5c,python/cpython,",bug",Security,single,Null pointer reference,Null pointer reference,"the bug occurred return the value which can be NULL instead of a dict, causing error",Within function,Cross-language API call site,PyDict_GetItemString,"foreign, PyDict_GetItemString",format handling,c to py,Crash,create a new variable to get the returned value and add if statement to check whether it is NULL,Within function,API function,"Detecting such bugs can be challenging in multi-language projects because different languages have different initialization requirements and behaviors. In this case, the Python interpreter expected a certain state for a new module object, which was not met, leading to a crash. This kind of issue requires a deep understanding of the language's internals and can be difficult to detect without comprehensive testing or static analysis tools.",,
0c1ceaf66ddb8cdaecd9d43f4f47abb8151a1ddb,python/cpython,",bug",Programming,single,"Missing a variable initialization, rl_attempted_completion_over variable to a non-zero value, Readline will not perform its default completion even if this function returns no matches.",initialization,the bug occurred in a function which was not setup well,Within function,Assignment,PyObject_CallFunction,"foreign, PyObject_CallFunction",Call Protocol,c to py,Unexpected Behavior,in Py function call,Within function,Cross-language API call site,"The challenge in detecting this bug in a multi-language project would be in understanding the specific behaviors and expectations of the readline module in Python, which may not be directly comparable to similar modules or functions in other languages. ",,
176014ffad8d39820293b63bf7177a7d2953343a,python/cpython,",bug",Programming,single,The bug was caused by the lack of certain API calls in the Python set object.,Logic error,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,"PyType_IsSubtype, PyErr_BadInternalCall","foreign, PyType_IsSubtype, PyErr_BadInternalCall","format handling, Exception Handling",c to py,Performance Issue,"The bug was fixed by adding the missing API calls. The PySet_Next(), PySet_Update(), and PySet_Clear() functions were implemented in the CPython codebase.",Within function,API function,"In this case, the missing API calls were not immediately obvious until a need for them arose during the development process.",,
b32b72e3d98d784b98d9c38d4f9905574a60707d,numpy/numpy,",00 - Bug",Security,single,"memory leak - a foreing function is called to create a new object based on an existing object, but the existing object is not decremented in its reference count, causing memory leak",Reference count misuse,"the bug occurred after the original/exwasting object was created and checked against NULL (i.e., a conditional structure/ if block) both using foreign functions",Within function,Following a foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,crash,before a if statement,Within function,API function,"the main challenges in detecting this bug would be the need to understand and analyze the interaction between Python and C code. NumPy is a Python library, but it uses C for performance-critical parts of its implementation. Therefore, understanding this bug requires knowledge of both Python and C, and the ability to analyze how they interact in the context of the NumPy project. ",,
b63e25648f2d7d0c2d56851352740620848da3ae,numpy/numpy,",00 - Bug",Security,single,memory leak,Reference count misuse,the bug occurred after the exwasting object get the value both using foreign functions,Within function,Following a foreign function call,"PyLong_AsLong, Py_DECREF","foreign, Py_DECREF","format handling, Memory Management",c to py,crash,change decrementing reference count function place,Within function,API function,"one of the main challenges in detecting this bug would be the need to understand and analyze the interaction between Python and C code. NumPy is a Python library, but it uses C for performance-critical parts of its implementation. Therefore, understanding this bug requires knowledge of both Python and C, and the ability to analyze how they interact in the context of the NumPy project. ",,
bdb5cc7b54d19f1f79eba1680a59f6852c6e3614,numpy/numpy,",00 - Bug",Security,single,memory leak,Reference count misuse,the bug occurred after the exwasting object get the value and checked against NULL,Within function,Following a foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,crash,"In if statement,  add Py_DECREF",Within function,API function,"one of the main challenges in detecting this bug would be the need to understand and analyze the interaction between Python and C code. NumPy is a Python library, but it uses C for performance-critical parts of its implementation. Therefore, understanding this bug requires knowledge of both Python and C, and the ability to analyze how they interact in the context of the NumPy project. ",,
35a793c31faa1d7aeb1fd44cf79407132efcab08,numpy/numpy,",00 - Bug",Security,multi,Null pointer reference,Null pointer reference,the bug occurred in the if-statement,Within function,Cross-language API call site,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,crash,the if statement add the value checking,Within function,API function,"one of the challenges in detecting this bug could be the interaction between different languages. For example, the representation of NULL or equivalent in different languages might vary, and the casting operation might behave differently.",,
2b18f72ad0784abdbc2eb302eb84511f62042a9b,numpy/numpy,",00 - Bug",Security,single,memory leak,Reference count misuse,"the bug occurred in a assiment, the varialbe on the right side shoud be decref, but it incref before the assigment. ",Within function,Following a foreign function call,"Py_DECREF, Py_INCREF","foreign, Py_INCREF",Memory Management,c to py,crash,"delete a wrong  incref, and add a incref and a decref at right place",Within function,API function,"detection challenge in identifying the bug is ensuring consistent reference counting across different languages. This involves carefully tracking and managing the reference counts of objects shared between different language interfaces, such as Python and C/C++.",,
f079a56b18714bd622f7ca457d14ebe873b67c55,numpy/numpy,",00 - Bug",Programming,single,Invalid dtypes comparison should not return NULL(raise TypeError),return value error,the bug occurred in returning a incorrect value,Within function,return,PyErr_Clear,"foreign, PyErr_Clear",Exception Handling,c to py,Data Corruption,change the return statement to Py_RETURN_NOTIMPLEMENTED,Within function,API function," identifying the occurrence of invalid dtype (data type) comparisons that raise a TypeError when they shouldn't. This bug occurs when incompatible data types are compared, leading to unexpected errors instead of appropriate type conversion or error handling. Detecting such instances requires analyzing code logic, identifying comparison operations, and verifying that the data types being compared are compatible or can be appropriately converted.",,
04ab04d93d4d7a4d241fe0ceb725436a8b6c8c2e,numpy/numpy,",00 - Bug",Security,single,buffer overflow,buffer overflow,the bug occurred when accessing the array.,Within function,access array,PyErr_Format,"foreign, PyErr_Format",Exception Handling,c to py,crash,Move the modification of the array index value to after the accessing the array,Within function,True/false branch,"identifying and fixing out-of-bounds access in functions like ""convert_datetime_divisor_to_multiple."" This requires careful analysis of the code to identify potential scenarios where the function might access memory beyond its allocated boundaries. As different programming languages have varying memory management models, understanding the intricacies of each language is essential to ensure the detection and resolution of such bugs.",,
df821062b1f2fa2b6d689cef5b89bf76ad9df4d0,numpy/numpy,",00 - Bug",Security,single,integer overflow,Data type error,the bug occurred in a function call which was not accept the argument type,Within function,Cross-language API call site,PyTuple_SET_ITEM,"foreign, PyTuple_SET_ITEM",format handling,c to py,crash,<same with bug location>,Within function,API function,"identifying and resolving compatibility issues between different programming languages and platforms. In the case of fixing a ValueError in PyArray_Std on win_amd64, it requires understanding the underlying interactions between the Python language, the NumPy library, and the Windows operating system. ",,
c33992faa1d0686c992ff1b51cbbb871c755a59a,numpy/numpy,",00 - Bug",Security,single,Null pointer reference,Null pointer reference,the bug occurred in an if statement,Within function,loop body,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,crash,<same with bug location>,Within function,Conditionals (predicate/conditional expression)," identifying the potential use of a null pointer in nditer buffers. This bug involves detecting instances where a null pointer is accessed or manipulated within the buffers of nditer objects. Detecting this bug requires analyzing the code across multiple languages and identifying situations where null pointers are being used without proper checks, which can be complex due to the interaction between different programming languages and their memory management systems.",,
ae317fd9ff3e79c0eac357d723bfc29cbd625f2e,numpy/numpy,",00 - Bug",Security,single,buffer overflow,buffer overflow,the bug occurred in an if statement,Within function,return,PyArray_NewFromDescr_int,"foreign, PyErr_Format",Exception Handling,c to py,crash,Move the code from below the bug line to above it for boundary checking,Within function,if structure,"Buffer overflows occur when a program tries to store more data in a buffer than it can hold, leading to memory corruption and potential security breaches. Detecting such vulnerabilities requires thorough code analysis and understanding of memory management across different programming languages, as each language has its own specific mechanisms for handling buffers.",,
a9962f2632003399946951c96ac6d6e3d3124ed7,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,"when the error occurred, it should stop and return instead exiting current loop and goto next loop",error handling,the bug occurred in a loop which may return incorrct value,Within function,Following a foreign function call,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Unexpected Behavior,"change break statement to goto, lead the code to right place",Within function,if structure,"NumPy is written in a combination of Python and C, and the error handling mechanisms in these two languages are different. Therefore, ensuring correct error propagation and handling across the language boundary can be challenging. Additionally, the bug was in a low-level iterator function, which could be used in various contexts, making the bug's effects potentially widespread and its detection more difficult.",,
2eb2e93ef43618f01258c43f4e7024cb5e3fc173,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,Null pointer reference,Null pointer reference,"the bug occurred in a loop, a lwast want to access out of bounds",Within function,Following a foreign function call,Py_INCREF,"foreign, PyErr_NoMemory",Exception Handling,c to py,Crash,add a if statement to chenck the variable wether it is NULL,Within function,API function,"one challenge in detecting this bug could be the differences in memory management across different languages. In some languages, memory allocation failures are automatically handled and would throw an exception, but in C, it's the programmer's responsibility to check if memory allocation functions like malloc succeed. This requires careful attention to detail and a deep understanding of how memory management works in C.",,
b51b540285d4cf2af69976c1e3b285f7c21b46f7,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,type int and py_ssize_t are not match in assigment statement,Data type error,the bug occurred in a assiment with the API function call,Within function,Cross-language API call site,PyBytes_Size,"foreign, PyBytes_Size",format handling,c to py,Data Corruption,"delete the type casting, move it to right place",Within function,API function,The main challenge in detecting this bug in a multi-language project is that it involves understanding the nuances of type casting in C and the potential for data loss. This requires a deep understanding of the C language and the specific data types used.,,
9437402f1d60778cd723e6119044ef0510ef17c0,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,Null pointer reference,Null pointer reference,the bug occurred in a assiment in which variables need to be changed,Within function,Following a foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,<same with bug location>,Within function,assignment,"one of the challenges in detecting this bug could be the different ways null pointers are handled in different languages. In some languages, accessing a null pointer might not cause a crash but could lead to other unexpected behavior. ",,
028bdf88e6c71a705d0c6bfd55d1117c7f44f6aa,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,Null pointer reference,Null pointer reference,"the bug occurred in the if-statement, the value in if get from a function",Within function,Conditional (predicate/conditional expression),Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,<same with bug location>,Within function,Conditionals (predicate/conditional expression),"the challenge in detecting this bug could be the different ways null pointers are handled in different languages. In some languages, comparing a null pointer with 0 might be acceptable, but in C, a null pointer should be compared with NULL.",,
5c7002926ec8ad12785b36024f9da80b7017ad1c,numpy/numpy,",00 - Bug",Security,single,uninitialize the variable,initialization,the bug occurred in first time use the variable,Within function,Assignment,PyTuple_Check,"foreign, PyTuple_Check",format handling,c to py,Unexpected Behavior,the bug occurred in the start of a function,Within function,Cross-language API call site,"detecting issues with the initialization value of ""no_castable_output"" used in ""ufunc_loop_matches"" can be challenging. Ensuring consistent and compatible initialization values across languages is crucial to prevent unexpected behavior and potential bugs in the project. ",,
565fe77f9ed8ed5720b42ddc3dc30947a1f3e9ae,numpy/numpy,",00 - Bug",Security,single,memory leak,Reference count misuse,the bug occurred before return,Within function,Following a foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,<same with bug location>,Within function,API function,"Python has automatic garbage collection, while C requires manual memory management. Therefore, when these two languages interact, as in the case of NumPy (which is written in both Python and C), it can be difficult to ensure that memory is properly managed across both languages.",,
41ccadd2b2685cc7dcbba720e6dce246205d65dc,numpy/numpy,",00 - Bug,component: numpy.dtype",Programming,single,Do not inherit flags from the structured part of a union dtype,logic error,"the bug occurred after an if statement, which give a new value to variable",Within function,Assignment,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,<same with bug location>,Within function,if structure,one of the challenges in detecting this bug could be the deep understanding required of the different dtypes and how they should behave. This is especially true when dealing with complex structures like union dtypes.,,
2f156d8e3eb4f57067209fa4499eaeed8551c4ae,numpy/numpy,",00 - Bug,component: numpy.dtype",Programming,single,"In if statement, the condition allow the float convert to timedelta causing error",logic error,the bug occurred in an if statement,Within function,Following a foreign function call,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Unexpected Behavior,<same with bug location>,Within function,API function,"the challenge in detecting this bug lies in the fact that different languages have different type systems and rules for type promotion. Therefore, a bug like this might not be immediately obvious unless the specific combination of types is tested. ",,
95a6774007d1d7898c7da40d9989e9f1dd1b0f40,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,uninitialize the variable,initialization,the bug occurred in first time use the variable,Within function,Assignment,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,the bug occurred in the start of a function,Within function,Cross-language API call site,"one of the challenges in detecting such bugs could be the differences in initialization requirements and behaviors across different programming languages. Some languages automatically initialize variables, while others, like C, do not. This can lead to overlooking initialization issues when working across multiple languages.",,
cb98ad400c701f189d4e4043ee2cb44857733df4,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,memory leak,Reference count misuse,the bug occurred in the start of a function and aftrer initialization,Within function,Cross-language API call site,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,<same with bug location>,Within function,Cross-language API call site,"The main challenge in detecting this bug is the inherent complexity of managing reference counts in C, especially in a multi-language project like NumPy which interfaces with Python. Such bugs may not cause immediate crashes or obvious symptoms, but can lead to subtle memory leaks that are hard to detect and trace back to their source. ",,
2d1bd21fe45ed096bccf665d4a8bb1ec5bf7c018,numpy/numpy,",00 - Bug,component: numpy.ufunc",Security,multi,the loop times should be a larger number and without the boundry check for a function call may causing error,boundry error,the bug occurred in the for-statement argument and start of it,Within function,loop body,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Crash,change loop times to the other variable and add a boundry checking,Within function,loop body,"the bug only manifests under specific conditions (i.e., when the output causes broadcasting of the input arrays), which may not be covered by standard test cases.",,
2d1bd21fe45ed096bccf665d4a8bb1ec5bf7c018,numpy/numpy,",00 - Bug,component: numpy.ufunc",Security,multi,Null pointer reference,Null pointer reference,the bug occurred in the for-statement argument and start of it,Within function,loop body,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Crash,change loop times to the other variable and add a boundry checking,Within function,if structure,"the bug only manifests under specific conditions (i.e., when the output causes broadcasting of the input arrays), which may not be covered by standard test cases.",,
a9652077be95f83f56c9b77e7ad1ed7710516626,numpy/numpy,",00 - Bug,component: numpy.core",Cross,single,Interruption (early termination) of cross-language error handling,error handling,the bug occurred out of the function,Within function,return,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Crash,change error raising function and add a error handle function,Within function,True/false branch,"the error handling mechanisms in these two languages are different. Therefore, ensuring correct error propagation and handling across the language boundary can be challenging. Additionally, the bug was in a low-level iterator function, which could be used in various contexts, making the bug's effects potentially widespread and its detection more difficult.",,
ce3d79a7c41e6be0a3ad0e8e3214f96fe29c77f9,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,memory leak,Reference count misuse,the bug occurred after using the varrialbe without free,Within function,function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,After the variable which need to be free after use,Within function,variable,"the challenge in detecting this bug lies in the fact that memory management in C is manual. This means that developers must explicitly free any memory they allocate. In a multi-language project, where some languages may handle memory management automatically, it can be easy to overlook this requirement in the C portions of the code. ",,
fc2518ba6b11fc52b0ff477b9e83576be90562d8,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,memory leak,Reference count misuse,"the bug occurred in a assiment, since the variable have wrong refcount",Within function,Cross-language API call site,"Py_DECREF, Py_INCREF","foreign, Py_DECREF, Py_INCREF",Memory Management,c to py,Crash,"In if statement,  add Py_DECREF and PyINCREF",Within function,API function,"the challenge in detecting this bug lies in the nuances of memory management across different languages. In Python, for example, memory management is largely handled by the interpreter, while in C, developers have direct control over memory allocation and deallocation. ",,
8cb86fd7b454b40c7b822146d5e26c55fdc183ec,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,Null pointer reference,Null pointer reference,the bug occurred out of the function,Within function,return,Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,Unexpected Behavior,change the return statement,Within function,if structure,Detecting this bug would be challenging in a multi-language project because it involves understanding the nuances of how numpy handles different types of arrays. It would require a deep understanding of numpy's internal workings and the ability to trace the flow of data through multiple functions and modules.,,
54b11918beda8454dab062498af81754a7034055,python/cpython,",bug",Programming,single,"the problem in code position under two switch cases. The bug was caused by an oversight in the Python interpreter's handling of in-place division (""/="") when the ""-Qnew"" option was used. This issue was particularly evident when running Python from IDLE.",Logic Error,"thd bug occurred in switch-case statement, the code under two cases was reversed",Within function,True/false branch,PyNumber_InPlaceTrueDivide,"native, PyNumber_InPlaceTrueDivide",Number Protocol,c to py,Data Corruption,in the switch case statement,Within function,API function,"the challenge in detecting this bug lies in the specific context in which it occurs - the ""-Qnew"" option in IDLE. It might not be immediately obvious to test this specific scenario, especially if the focus is on more commonly used features or environments. Additionally, the bug only manifests in the IDLE environment, which adds another layer of complexity to its detection.",,
b67ad7e67159365faa1e61d436df99010bc7c97d,python/cpython,",bug",Programming,single,"The cmath.log function did not support an optional base argument. This is inconsistent with the behavior of the math.log function, which does support an optional base argument.",Logic Error,the bug occurred in argument initialization,Within function,Assignment,PyModule_AddObject,"foreign, PyModule_AddObject",Object,c to py,Unexpected Behavior,"The fix involves modifying the cmath_log function to parse an optional second argument (&y). If this argument is provided (PyTuple_GET_SIZE(args) == 2), the function computes the logarithm of x with respect to this base (x = c_quot(x, c_log(y))). ",Within function,API function,"The main challenge in detecting this bug is that it's not a typical ""error"" in the code, but rather a missing feature that exists in a similar function in another module. This requires a deep understanding of the Python language and its standard library, as well as the ability to compare the behavior of similar functions across different modules. ",,
354e3d90d346afdc6c70211b130aa76bb18e19ed,python/cpython,",bug",Programming,single,The original implementation of the zipimport module in Python did not support importing from files which contain a zip-archive at the end but contain other things as well (like an exe-stub).,File I/O error,"The bug occurred after the initialization of the variable ""file_offset."" When the code wants to call Py_BuildValue() to use the value of file_offset.",Within function,Cross-language API call site,PyMarshal_ReadLongFromFile,"foreign, PyMarshal_ReadLongFromFile",Data marshalling support,c to py,Unexpected Behavior,"The changes include calculating the offset from the beginning of the file to the start of the zip-archive (arc_offset), and adjusting header_offset and file_offset accordingly. ",Within function,Cross-language API call site,The main challenge in detecting this bug is that it only manifests in a specific use case - when trying to import from a file that contains a zip-archive at the end and other content at the beginning.,,
96b1c903f5310202a665e86e624a38ede50429c3,python/cpython,",bug",Programming,single,The bug was caused by the os.listdir() function in Python not correctly handling Unicode strings. The function was supposed to return Unicode strings only when it was called with a Unicode argument.,Data type error,the bug occurred in an if statement,Within function,Cross-language API call site,PyArg_ParseTuple,"foreign, PyArg_ParseTuple",Parsing arguments,py to c,Unexpected Behavior,"The bug fix involved modifying the behavior of the os.listdir() function to ensure that it only returns Unicode strings when it is called with a Unicode argument. Additionally, the function was updated to use the default encoding if Py_FileSystemDefaultEncoding is NULL. ",Within function,API function,the main challenge in detecting this bug is the nuanced handling of Unicode strings and encodings.,,
298e4214538a7196c27ec22b1f01506fdb3c4039,python/cpython,",bug",other,single,the default __new__ to refuse arguments iff tp_init is the default __init__ implementation,other,the bug occurred in the instantiation of a class that has the default __init__ method but was passed arguments during instantiation,Within function,Cross-language API call site,PyTuple_GET_SIZE,"foreign, PyTuple_GET_SIZE",Object,c to py,Type Error,<same with bug location>,Within function,API function,"It doesn't cause a crash or an immediate error, but rather results in silent failure where arguments are ignored.",,
7d9ea5013f2f6122aa83a68429bf2dd5e5a00017,python/cpython,",bug",Programming,single,The zlibmodule.c sources mistakenly didn't implement flush() on decompression objects. The assumption was that all data would have been extracted once all of the source is available.,logic error,the bug occurred in the statement which was calling a API function,Within function,Cross-language API call site,PyArg_ParseTuple,"foreign, PyArg_ParseTuple",Parsing arguments,py to c,Unexpected Behavior,<same with bug location>,Within function,API function,"The challenge in detecting this bug lies in the implicit assumption that all data would have been extracted once all of the source is available. This assumption might not be immediately clear or intuitive, especially when working with multi-language projects where different languages might handle such scenarios differently.",,
4f707ac8b13a03609bc7618f7e7b17b97b7a0aeb,python/cpython,",bug",Programming,single,"The bug is caused by the SSL connection not properly handling non-blocking sockets or sockets with a timeout set. When a socket timeout is set, the SSL connection operation fails with a timeout error.",error handling,"the bug occurred in the SSL connection operation, specifically at the SSL_connect(self->ssl) call ",Within function,loop body,Py_INCREF,"foreign, Py_INCREF",Memory Management,c to py,DeadLock,"after set the socket for SSL, missing on-blocking mode or timeout mode",Within function,API function,"The main challenge in detecting this bug is the need to understand the interaction between Python's socket module and the SSL module, and how socket settings (like non-blocking mode or timeout) affect SSL operations. This requires knowledge of both Python and C, as well as the OpenSSL library, making it a complex multi-language issue.",,
9a3129c14866f21ce3cee053c085db374cb61b78,python/cpython,",bug",Security,single,"The bug was caused by an attempt to resize a string created by PyString_FromStringAndSize using _PyString_Resize, which fails for strings with length 0 or 1 as it returns an interned string in those cases.",miss input validation,"the bug occurred in the part of the code where _PyString_Resize was called on a string created by PyString_FromStringAndSize. After that, there was an if statement to check buffer.",Within function,Cross-language API call site,PyMem_Malloc,"foreign, PyMem_Malloc",Memory Management,c to py,Crash,The bug was fixed by rewriting the offending code to simply allocate a new buffer and avoid using _PyString_Resize altogether.,Within function,API function,"one of the challenges in detecting this bug could be understanding the nuances and intricacies of Python's C API, particularly when it comes to handling strings and memory management. ",,
a797d8150dd6fd8336653d8e91db3c088f2c53ff,python/cpython,",bug",Programming,single,The Python dict() constructor did not originally support initialization from keyword arguments. This was inconvenient for developers who wanted to create dictionaries with literal keys directly using the dict() constructor.,logic error,the bug occurred when calling PyArg_ParseTupleAndKeywords to create dictionary  from keyword arguments.,Within function,Cross-language API call site,PyArg_ParseTuple,"foreign, PyArg_ParseTuple",Parsing arguments,py to c,Unexpected Behavior,<same with bug location>,Within function,API function,"The main challenge in detecting this bug is understanding the different use cases of the dict() constructor.  In this case, the bug was not a traditional ""error"" but rather a limitation in the design of the dict() constructor that was inconvenient for developers.",,
817918cc3c10d0ed6b14e0e3f2bc0c5227c508cd,python/cpython,",bug",Programming,single,"The bug was due to the lack of support for the ""str1 in str2"" operation when ""str1"" was more than a single character in Python's string and Unicode handling.",logic error,the bug occurred in mwassing the single character which may causing the returned value incorrect,Within function,Cross-language API call site,PyUnicode_GET_SIZE,"foreign, PyUnicode_GET_SIZE",Object,c to py,Unexpected Behavior,<same with bug location>,Within function,API function,"The main challenge in detecting this bug is the implicit assumption that the ""in"" operation would only be used with single-character strings. This assumption might not be explicitly documented or enforced in the code, making it difficult to identify the bug during code reviews or static analysis. ",,
9c5b61b21bae24bdfc168b5876dbe1396c28868a,python/cpython,",bug",Programming,single,"The original implementation of the GetFInfo function was not able to retrieve information for folders. The function was designed to work with files, and when used with folders, it was not returning the correct information.",API misuse,"the bug occurred in the GetFInfo function, specifically where the FSpGetFInfo function was called.",Within function,function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,The bug was fixed by using the PBGetCatInfoSync function instead of the GetFInfo function. This change was made under the conditional compilation flag USE_CATINFO_FOR_FINFO. The PBGetCatInfoSync function is able to retrieve the correct information for both files and folders.,Within function,True/false branch,The main challenge in detecting this bug is understanding the different behaviors of the GetFInfo and PBGetCatInfoSync functions.,,
35fc7606f076f507bd25acaf464e83c75c3756f4,python/cpython,",bug",Performance,single,"The bug was caused by the inefficient handling of memory in Python's tuple and list objects. The original code used a loop to initialize memory, which was replaced with a more efficient memset() function",resource,the bug occurred in the PyTuple_New() function where the loop was replaced with memset() and in the _PyTuple_Resize() function where the loop was also replaced with memset().In the _PyTuple_Resize() function where the loop was also replaced with memset().,Within function,loop body,PyErr_BadInternalCall,"foreign, PyErr_BadInternalCall",Exception Handling,c to py,Performance Issue,<same with bug location>,Within function,loop body,"The main challenge in detecting this bug is that it doesn't cause a visible error or crash, but rather a performance issue. ",,
a039274cccd24631f2b2de39d31ae4ffe7399bf8,python/cpython,",bug",Programming,single,The bug was caused by the lack of a mechanism to prevent duplicate entries in Python's readline history when using the ^P command to re-execute the previous command. This was fixed by adding a check to prevent duplicate entries from being added to the history.,initialization,the bug occurred in the line add_hwasry(p); was where the duplicate entries are added to the hwasry.,Within function,True/false branch,PyMem_Malloc,"foreign, PyMem_Malloc",Memory Management,c to py,Unexpected Behavior,<same with bug location>,Within function,True/false branch,one of the challenges in detecting this bug could be the understanding of how different components interact with each other,,
820867662bf35a2d8d2234f8cd4c8ce316ebfd37,python/cpython,",bug",Performance,single,"The bug is due to the absence of an implementation for the GetEventParameter function, which is crucial for handling 'cmds' events (Command events).",function misuse,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Within function,Cross-language API call site,PyArg_Parse,"foreign, PyArg_Parse",Parsing arguments,py to c,Unexpected Behavior,<same with bug location>,Within function,API function,"The challenge in detecting this bug lies in the fact that it involves a missing implementation, which may not be immediately apparent unless one is familiar with the requirements of handling 'cmds' events. ",,
169192e8184fe742c9694bb2ba9a545302a0fc44,python/cpython,",bug",Performance,single,"he original code used strcpy() to copy a string, which iterates through the string until it finds a null character. However, the length of the string was already known and stored in size, so using memcpy() instead can improve speed as it directly copies size bytes.",resource,The bug occurred in a non-foreign function call which was in an if statement,Within function,function call,Py_INCREF,"foreign, Py_INCREF",Memory Management,c to py,Performance Issue,<same with bug location>,Within function,function call,"The main challenge in detecting this kind of issue is that it doesn't cause an obvious failure or incorrect behavior. Instead, it subtly affects performance. ",,
dc5af70631c86723132518152ce5f910848d83ae,python/cpython,",bug",Security,single,memory leak,Reference count misuse,The bug occurred in some if statements,Within function,Cross-language API call site,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,crash,the bug occurred after checking and before return NULL,Within function,if structure,"The main challenge in detecting this bug is that it involves memory management in C, which can be difficult to track and debug. Additionally, the bug only manifests in specific situations",,
340cbe74b9e26823cdc7e7803e5fbdb9e6946f6e,python/cpython,",bug",Programming,single,missing initialization to __module__ causing error.,Initialization,the bug occurred in start of the function which should do some initialization,Within function,Assignment,Py_DECREF,"native, Py_DECREF",Memory Management,c to py,Unexpected Behavior,at the bug location to initializes the __module__ local in a class statement from the __name__ global.,Within function,assignment,"the challenge lies in understanding the nuances of Python's metaclass mechanism and how it interacts with the __module__ attribute. Additionally, the bug is subtle and does not cause a crash or an immediate noticeable error, making it harder to detect. ",,
cc7038fb59f8dbe8ff08cae4723aca38169a5a59,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,memory leak,Reference count misuse,The bug occurred in some if statements,Within function,Cross-language API call site,PyBytes_Check,"foreign, PyBytes_Check",Object,c to py,Unexpected Behavior,<same with bug location>,Within function,API function,the challenge lies in correctly interpreting and handling different types of errors across different parts of the code written in different languages,,
482625dd29b4f3f3c43a731611063286f8bffb73,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,"The bug was caused by the lack of proper axis check for lexsort function in numpy. This allowed nonsensical values like axis=1000 for 0D arrays, which is not a sane behavior.",special case,the bug occurred in an if statement,Within function,return,Py_XDECREF,"foreign,  Py_XDECREF","Memory Management, Object",c to py,Unexpected Behavior,<same with bug location>,Within function,if structure,"the bug is related to a specific function (lexsort) and a specific parameter (axis), which makes it even more challenging to detect without a thorough code review or specific test cases.",,
52c9e6f2e3e72081576fc7f629fe3eb0c67b143b,numpy/numpy,",00 - Bug,03 - Maintenance",Programming,single,The root cause of the bug was improper handling of the conform_reduce_result function in the numpy codebase. The function was not properly handling the strides and shapes of arrays during reduction operations.,Data type error,the bug occurred in an if statement,Within function,Conditional (predicate/conditional expression),Py_INCREF,"foreign,  Py_INCREF","Memory Management, Object",c to py,Unexpected Behavior,<same with bug location>,Within function,if structure,The main challenge in detecting this bug is understanding the complex logic of numpy's reduction operations and how strides and shapes are handled.,,
f01b4e54a4b46a84a5a79b03bd2bd2f21b190f12,numpy/numpy,",00 - Bug,component: numpy.core",Programming,multi,The bug was caused by the empty_like function not respecting a shape of (). This was because the function was treating shape=() the same as shape=None.,special case,the bug occurred in an if statement,Within function,Conditional (predicate/conditional expression),PyArg_ParseTupleAndKeywords,"foreign,  PyArg_ParseTupleAndKeywords",Parsing arguments,py to c,Unexpected Behavior,<same with bug location>,Within function,Conditionals (predicate/conditional expression),The main challenge in detecting this bug is understanding the subtle differences in how different inputs should be handled.,,
f01b4e54a4b46a84a5a79b03bd2bd2f21b190f12,numpy/numpy,",00 - Bug,component: numpy.core",Programming,multi,The bug was caused by the empty_like function not respecting a shape of (). This was because the function was treating shape=() the same as shape=None.,return value error,the bug occurred in an if statement,Within function,function call,PyArg_ParseTupleAndKeywords,"foreign,  PyArg_ParseTupleAndKeywords",Parsing arguments,py to c,Unexpected Behavior,<same with bug location>,Within function,function call,The main challenge in detecting this bug is understanding the subtle differences in how different inputs should be handled.,,
642181c76b11bd1cc87ee7443d3ee215744df0fd,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,"The bug was caused by the code incorrectly handling an empty tuple of strides in ndarray.__new__. Previously, an empty tuple was treated as if no strides were passed, which was not the intended behavior.",special case,the bug occurred in an if statement,Within function,Conditional (predicate/conditional expression),PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Unexpected Behavior,<same with bug location>,Within function,Conditionals (predicate/conditional expression),"The main challenge in detecting this bug is understanding the intended behavior of the code when different types of inputs are provided. In a multi-language project, it can be particularly challenging to keep track of how different types of data (like tuples in Python) should be handled in different parts of the code (like C code).",,
637af579ef5985bd8c267817cf445aca5bb34531,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,missing error checking,unhandle exception,"The bug occur in the wrap_aligned_contig_transfer_function function, where the init_dest and out_needs_api parameters are used without proper error-checking.",Within function,loop body,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Unexpected Behavior,<same with bug location>,Within function,if structure,"the bug involves a lack of error-checking, which can be difficult to detect without a deep understanding of what the code is supposed to do.",,
40fad321343dd8a28129c668c8037a35e9b33989,numpy/numpy,",00 - Bug,58 - Ready for review,triaged",other,single,"The bug was caused by the __array__ method not being used during dimension discovery, while it was used during dtype discovery (if dtype is not given) and during the filling of the resulting array. This inconsistency led to incorrect shape retention when converting certain ""array-like"" objects (e.g., Pandas objects) to NumPy arrays.",other,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,Py_DECREF,"foreign, Py_DECREF","Memory Management, Object",c to py,Unexpected Behavior,"the fix would likely involve ensuring the __array__ method is used consistently during all stages of the array creation process, including dimension discovery.",Within function,if structure,"The main challenge in detecting this bug is that it only manifests under specific conditions, i.e., when converting ""array-like"" objects that have a certain shape and implement certain interfaces to NumPy arrays.",,
1f9ab28a9ee5a0cda956da35d0c77a3a4c4bcd55,numpy/numpy,",00 - Bug,triage review",Programming,single,"The bug was caused by the use of deprecated Py_UNICODE APIs that were error-prone. These APIs worked with either UCS2 or UCS4, depending on the value of Py_UNICODE_WIDE. ",API misuse,The bug occur in the UNICODE_setitem function where the deprecated Py_UNICODE APwas were being used.,Within function,function call,PyObject_Str,"foreign, PyObject_Str",Object,c to py,Performance Issue,The bug fix involved replacing the deprecated Py_UNICODE APIs with the new way of handling unicode characters introduced in Python 3.3. This involved changes in the UNICODE_setitem function and other related parts of the code.,Within function,function call,"The challenge in detecting this bug is understanding the nuances of the Python C API, especially the changes between different Python versions. ",,
491f41acd2c6a0e7886662a2448b3d245ae432a9,numpy/numpy,",00 - Bug,Priority: high",Security,single,Null pointer reference,Null pointer reference,"The bug occurred after an assiment, which may get NULL value",Within function,return,PyObject_IsTrue,"foreign, PyObject_IsTrue",Object,c to py,Crash,<same with bug location>,Within function,if structure,"The challenge in detecting this bug lies in the fact that it only occurs under specific circumstances, i.e., when objects that do not have a truthiness defined are processed. ",,
6d889e7eca0f7ae6d640c380bd0b604e6530f049,numpy/numpy,",00 - Bug",Security,single,memory leak,Reference count misuse,The bug occurred in the @name@_arrtype_new and similar functions where the arguments are not properly checked.,Within function,return,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,The bug fix involves adding checks to the arguments passed to the scalar constructors.,Within function,True/false branch,"The challenge in detecting this bug lies in the fact that it involves the misuse of function arguments, which may not be immediately obvious without a thorough understanding of the expected behavior of the functions. ",,
a5e5e51187d4476841503ce816924ea99936dba0,numpy/numpy,",00 - Bug",Security,single,memory leak,Reference count misuse,The bug can occurred in any place where PyDict_SetItemString was called without checking its return value for an error.,Within function,return,"PyDict_SetItemString, Py_DECREF","foreign, PyDict_SetItemString, Py_DECREF","Memory Management, Object",c to py,Unexpected Behavior,The bug fix involves adding error handling after each call to PyDict_SetItemString.,Within function,if structure,"The main challenge in detecting this bug is that it involves a failure to handle an error condition, which may not manifest itself under normal conditions. ",,
674d96ef3da8e9b97b29acaefea432d2524f0ca4,numpy/numpy,",00 - Bug",Programming,single,"The bug was caused by the use of the PyDict_GetItem() function, which does not distinguish between a missing key and an exception (like MemoryError or KeyboardInterrupt). ",API misuse,The bug could occur at any place where PyDict_GetItem() was used.,Within function,return,"PyErr_Occurred,PyArg_Parse","foreign, PyErr_Occurred, PyArg_Parse","Exception Handling, Parsing",py to c,Unexpected Behavior,"The fix involves replacing all instances of PyDict_GetItem() with PyDict_GetItemWithError(). This new function is able to distinguish between a missing key and an exception, thereby preventing the misinterpretation. ",Within function,function call,"The main challenge in detecting this bug is understanding the Py Dict GetItem(), which can cause error.",,
7f2fbed6c0cbccdb41eea3005d5af3445a3c9879,numpy/numpy,",00 - Bug,component: numpy.ufunc",Programming,single,The bug is caused by the fact that the reduction operation does not correctly check and ensure that the output shape matches the input shape along non-reduction axes.,Logic error,the bug occurred in an if statement,Within function,return,PyErr_Format,"foreign, PyErr_Format",Exception Handling,c to py,Data Corruption,"The fix add a branch to check the output shape against the input shape along non-reduction axes. If the output shape does not match the input shape, an error is raised. ",Within function,True/false branch,The challenge in detecting this bug lies in the fact that it involves understanding the expected behavior of the reduction operation in the context of multi-dimensional arrays.,,
624d34cbda2f8f7614733743f028c0dd6a5c9952,numpy/numpy,",00 - Bug,component: numpy.dtype",Security,single,Null pointer reference,Null pointer reference,The bug occurred after some assigment.,Within function,Assignment,"PyDict_SetItem, PyErr_SetString","foreign, PyDict_SetItem, PyErr_SetString","Exception Handling, Object",c to py,Crash,<same with bug location>,Within function,if structure,"The main challenge in detecting this bug is that it involves exception handling, which can be difficult to identify without thorough testing. ",,
21e796e159dd4865a265b94a044ddb144e4e0af1,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,"The bug was caused by a discrepancy between the function signature in the docstring and the actual function implementation for ndarray.searchsorted. The docstring claimed that the function had a parameter named v, but the actual implementation used a parameter named keys.",Logic error,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,PyArg_ParseTupleAndKeywords,"foreign, PyArg_ParseTupleAndKeywords",Parsing arguments,py to c,Unexpected Behavior,<same with bug location>,Within function,Cross-language API call site,The main challenge in detecting this bug is that it involves a discrepancy between the documentation (docstring) and the actual code implementation.,,
480dc6bc01aa465389fcad0c85502d25d954f579,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,Null pointer reference,Null pointer reference,The bug occurred after some assigment.,Within function,Assignment,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Crash,<same with bug location>,Within function,Cross-language API call site,The main challenge in detecting this bug is that it involves an edge case (empty array input) that might not be immediately obvious.,,
6ed9365aadf992087b26ec30214dfec151ac22a1,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,integer overflow,Data type error,The bug occurred in an assigment,Within function,Assignment,PyLong_AsLong,"foreign, PyLong_AsLong",Object,c to py,Unexpected Behavior,The bug fix involves changing the type of the ndmin variable back to int from npy_intp and adding a check before assigning the result of PyLong_AsLong to it.,Within function,if structure,"The main challenge in detecting this bug is the cross-language nature of the project. The bug involves a subtle type mismatch between Python and C, which is not easily caught by standard debugging tools. ",,
af36784b2b38577a87208003d6827d02dc0c0fc2,numpy/numpy,",00 - Bug,06 - Regression",Programming,single,The root cause of the bug was the change of the ndmin local variable from an int to an npy_intp. &ndmin is passed to PyArg_ParseTupleAndKeywords against an i argument spec,Data type error,The bug occurred in an assigment,Within function,Assignment,PyLong_AsLong,"foreign, PyLong_AsLong",Object,c to py,Unexpected Behavior,The bug fix involves changing the type of the ndmin variable back to int from npy_intp and adding a check before assigning the result of PyLong_AsLong to it.,Within function,True/false branch,"The main challenge in detecting this bug is the cross-language nature of the project. The bug involves a subtle type mismatch between Python and C, which is not easily caught by standard debugging tools. ",,
908b60159b538bd9d8fe06dee68583629dd6dea4,numpy/numpy,",00 - Bug,component: numpy.f2py,58 - Ready for review",Security,single,memory leak,Reference count misuse,"the bug occurred after the original/exwasting object was created and checked against NULL (i.e., a conditional structure/ if block)",Within function,Assignment,PyObject_New,"foreign, PyObject_New",Objects?,c to py,Crash,<same with bug location>,Within function,if structure,"In this case, understanding the bug requires knowledge of both Python's memory management system and C programming. Furthermore, such bugs might not cause immediate issues and can remain undetected until they lead to significant memory leaks or crashes.",,
3d31770c61ea2412267c233d38ccc33d5d3a0610,numpy/numpy,",00 - Bug",Security,single,Null pointer reference,Null pointer reference,The bug occurred in a loop,Within function,loop body,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Crash,The bug fix adding a check before the loop which may causing error,Within function,if structure,"the challenge lies in the complexity of handling different data types and structures across different languages. The bug was a boundary case that was not initially considered, demonstrating the difficulty in predicting and testing all possible input scenarios.",,
79ee678fb2f1518b3f45e26066a02b45b22d456c,numpy/numpy,",00 - Bug,component: numpy.core,07 - Deprecation",Programming,single,"The bug is caused by the read functions in the code that stop the loop when they reach bad data. However, they do not check whether the file/string was actually read to its end. If not, they should give a DeprecationWarning.",Logic error,"The bug occurred in end of the function, which was not check reach the end of file",Within function,return,"PyErr_Occurred, Py_DECREF","foreign, PyErr_Occurred, Py_DECREF","Memory Management, Exception Handling",c to py,Unexpected Behavior,"the bug fix adding a new variable to check whether the file reach the end,-1 indicates end reached; ",Within function,if structure,the challenge in detecting this bug lies in understanding the interaction between the C code and the Python code. The C code is used to read data and the Python code is used to handle the data.,,
842079e235dfac64cf99059286e295b307d073fc,numpy/numpy,",00 - Bug,03 - Maintenance",other,single,The bug was caused by the misuse of the int type for variables that should have been of type npy_intp. This could lead to potential issues with integer overflow or underflow.,other,The bug occur at the locations where the variables of type int were used instead of npy_intp.,Within function,Assignment,PyObject_IsTrue,"foreign, PyObject_IsTrue",Objects?,c to py,Unexpected Behavior,The bug fix involved changing the data type of certain variables from int to npy_intp.,Within function,Cross-language API call site,"one of the challenges in detecting this bug is the difference in data types between C and Python. Python handles large integers gracefully, but in C, using an int can lead to overflow or underflow for large values.",,
f786041db9697f58b087e18198561db8b28235c4,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,divided by 0,divided by 0,the bug occurred in an if structure,Within function,True/false branch,"PyErr_SetString, Py_DECREF ","foreign, PyErr_SetString, Py_DECREF ","Memory Management, Exception Handling",c to py,Unexpected Behavior,<same with bug location>,Within function,True/false branch,"the bug is related to a specific use case (creating a view with a fieldless dtype and non-zero itemsize), which may not be immediately apparent in general testing or usage.",,
d6f7524defc808f32219528350429d5569696183,numpy/numpy,",00 - Bug,component: numpy.dtype",Programming,single,The bug occurs when trying to compare structured numpy arrays that have no fields.,Logic error,"The bug occur at the point of comparwason operation, which was a function call.",Within function,Non-foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,ValueError,<same with bug location>,Within function,True/false branch,"Structured numpy arrays are complex data structures that can have multiple fields, each with its own name and data type. ",,
4246ce2a391314acc1da90d56ff4f995d45e18a9,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,The bug was caused by the failure of the np.lexsort function when lexsorting some empty arrays with non-standard strides.,logic error,The bug occurred in an if statement,Within function,True/false branch,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Unexpected Behavior,<same with bug location>,Within function,if structure,"In this case, the handling of empty arrays with non-standard strides in C code within a Python library (NumPy) was the issue.",,
98bdde643af6443d68a8c6233807b75bd3f0ed80,numpy/numpy,",00 - Bug,component: numpy.f2py",Security,single,The created Fortran objects were referenced from the module globals and therefore were only garbage collected on module reload or interpreter shutdown.,memory allocations/releasing,"The bug occur in the initialization function of the f2py-generated module, specifically where Fortran objects are created and referenced from the module globals.",Within function,Cross-language API call site,PyObject_Del,"foreign, PyObject_Del",Objects?,c to py,Crash,<same with bug location>,Within function,Cross-language API call site,Understanding how memory management works in both languages and how they interact with each other is crucial.,,
22fe5427be1f3a0b186d01a09ff46092a42a0aa1,numpy/numpy,",00 - Bug,defunct ?€? difficulty: Intermediate",Programming,single,NumPy array creates a read-only copy.,variable misuse,The bug occurred at a function call.,Within function,Non-foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,<same with bug location>,Within function,function call,the challenge in detecting this bug lies in the subtlety of the behavior of fancy indexing on read-only subclasses of NumPy arrays.,,
608329acac78b98e9c1044dca23a4f287d639b24,numpy/numpy,",00 - Bug,component: numpy.datetime64",Programming,single,"The bug was caused by an implicit conversion of a Python float to a C integer. This was deprecated in Python 3.8, leading to a DeprecationWarning.",Data type error,The bug occurred in an assigment,Within function,Assignment,PyFloat_AsDouble,"foreign, PyFloat_AsDouble",Objects?,c to py,error msg-DeprecationWarning,<same with bug location>,Within function,API function,"The implicit conversion that caused the bug is a feature of Python that was deprecated in Python 3.8, but the codebase also involves C, which does not have the same deprecation. Therefore, the bug might not be immediately apparent without knowledge of the changes in Python 3.8.",,
9259a7ff720ebebdd90dbe5469f08ed386de5f1d,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,"The variable no_castable_output was not initialized before being passed by pointer to the ufunc_loop_matches function, where its value is read.",initialization,The bug occurred in the variable no_castable_output was declared and then passed to the ufunc_loop_matches function.,Within function,Non-foreign function call,PyErr_Format,"foreign, PyErr_Format",Exception Handling,c to py,Unexpected Behavior,The bug fix the init value.,Within function,Cross-language API call site,the challenge in detecting this bug lies in the fact that the use of uninitialized variables can lead to subtle and hard-to-detect issues.,,
8828560ea2e78f5884390bc22221109d783b3118,numpy/numpy,",00 - Bug,component: numpy.core,07 - Deprecation",Security,single,"The bug is caused by the buffer interface not requesting a writeable buffer, but the code still passing a writeable one when the warn-on-write flag is set. This can lead to deprecation warnings and unexpected behavior in code that expects writeable buffers but does not ask for them specifically.",buffer permission,The bug ooccurred at the assiment which was not request the access to writable buffer,Within function,Assignment,Py_INCREF,"foreign, Py_INCREF",Memory Management,c to py,Unexpected Behavior,<same with bug location>,Within function,if structure,the challenge in detecting this bug lies in the interaction between different languages and their expectations of the buffer interface.,,
95c243221da5bedb7230e9ff229748f50acaf869,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,The bug is caused by the handling of unusual bytestrings in the dtype() function.,integer overflow,the bug occurred in an if statement,Within function,Assignment,"PyErr_SetString, Py_INCREF","foreign, PyErr_SetString, Py_INCREF","Memory Management, Exception Handling",c to py,Unexpected Behavior,<same with bug location>,Within function,if structure,"It involves specific bytestring formats that are not commonly used, making it difficult to detect during routine testing.",,
5ce770ae3de63861c768229573397cadd052f712,numpy/numpy,",00 - Bug,component: numpy.core,07 - Deprecation",Security,single,The bug is caused by a recursive .dtype attribute lookup in the code path which checks dtype on one inheriting from np.void.,special case,the bug occurred in an if statement,Within function,Cross-language API call site,"PyErr_Clear, Py_DECREF","foreign, PyErr_Clear, Py_DECREF","Memory Management, Exception Handling",c to py,Crash,<same with bug location>,Within function,Cross-language API call site,"The bug involves a Python attribute (dtype) being accessed in C code, which requires understanding of both Python and C semantics. ",,
8d18405446cb1c7dc6db15be812a9b3fc531ede0,numpy/numpy,",00 - Bug,component: numpy.core,03 - Maintenance",Security,single,"The bug arises when the array is empty and the descriptor element size is also empty, leading to a situation where 0 bytes are allocated, which is not well defined.",Null pointer reference,the bug occurred in an if statement,Within function,Conditional (predicate/conditional expression),Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,<same with bug location>,Within function,if structure,The challenge in detecting this bug lies in the fact that it only occurs in a specific situation where both the array and the descriptor element size are empty.,,
ad84b69bda8eb5e2998370148b9e830d40099d5c,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,The bug was caused by a memory leak in the dtype constructor code when creating a dtype from a dictionary. The memory leak occurred because certain variables were not properly decremented and nullified after use.,Reference Count Misuse,the bug occurred before return,Within function,return,Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,crash,<same with bug location>,Within function,API function,The main challenge in detecting this bug is understanding the interaction between C and Python in the context of reference counting.,,
6420e7f528a6c42422966544e453bdb2805ff620,numpy/numpy,",00 - Bug,component: numpy.dtype",Programming,single,"The function incorrectly allows casting from simple to structured types for any casting mode except ""equiv"" and ""no"", and from structured to simple types for ""unsafe"" casting mode, regardless of the number of fields.",special case,the bug occurred in an if statement,Within function,True/false branch,PyDict_Next,"foreign, PyDict_Next",Objects?,c to py,Unexpected Behavior,<same with bug location>,Within function,if structure,The main challenge in detecting this bug is understanding the complex logic of the can_cast function and how it should behave in different scenarios.,,
31bb4ca66b040088e0ffa0b56070708801db12d0,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,"The root cause of the bug is that the size 0 was being passed to the PyDataMem_NEW and PyDataMem_RENEW functions. This is problematic because these functions do not handle size 0 correctly, leading to unexpected behavior.",special case,the bug occurred in a cross-language API which cannot accept the size 0,Within function,Cross-language API call site,"PyDataMem_RENEW, Py_DECREF","foreign, PyDataMem_RENEW, Py_DECREF",Memory Management,c to py,Unexpected Behavior,The bug fix add an if statement to check whether the varible is 0,Within function,assert,"The bug is in the C code, but it is triggered by certain Python operations. ",,
07c625cedd18d817b0941e39b4fe6a13caf034a1,numpy/numpy,",00 - Bug,03 - Maintenance,component: numpy.ufunc",Security,single,The bug was caused by an incorrect handling of exceptions in the ufunc (universal function) operations.,Null pointer reference,the bug occurred at function call statement,Within function,Non-foreign function call,"PyErr_SetObject, Py_DECREF","foreign, PyErr_SetObject, Py_DECREF","Memory Management, Exception Handling",c to py,Crash,The bug fix involves modifying the raise_binary_type_reso_error and raise_no_loop_found_error functions to correctly construct and raise the error messages.,Within function,Cross-language API call site,The bug is not immediately obvious without a deep understanding of how ufuncs work and how exceptions are supposed to be handled in these operations.,,
9776a73cee9eaaff6af40e971fa2bb7f8f1086c5,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,"The index array was decref'd (decremented reference count) before extracting the shape to construct the indices array. If the caller does not hold a reference (which happens when the caller passed a list from which a temporary array was constructed, for example), this leads to a use-after-free.",Reference count misuse,the bug occurred at a variable has been used after  released,Within function,Non-foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,The fix involves moving the Py_DECREF(arr) after the shape is extracted to construct the indices array. This ensures that the array is not freed before its shape is used.,Within function,Cross-language API call site,"Python's automatic memory management and C's manual memory management can lead to complexities. In this case, the bug is due to a misunderstanding of when Python objects can be safely decref'd in C code. ",,
52d173d9087f6fb09994b433a127f58d19875c98,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,The bug was due to the ndarray.dump function in NumPy not closing the file it opens.,File I/O error,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,"PyImport_ImportModule, Py_XDECREF","foreign, PyImport_ImportModule, Py_XDECREF","Importing Modules, Memory Management",c to py,crash,"The bug fix involved moving the ndarray.dump function to Python and ensuring that it closes the file it opens. The fix was implemented in Python rather than C, which involved calling the Python implementation directly rather than going through C.",Within function,Cross-language API call site,The main challenge in detecting this bug is that it does not cause an immediate and observable error.,,
51ebd808b65166b3b81b3070d4c53df13b0bbc6b,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,"The bug was caused by the np.array function clearing errors that occurred in PyMemoryView_FromObject. The function was not distinguishing between different types of errors and was clearing all of them, which could potentially hide important exceptions.",error handling,the bug occurred in an if structure,Within function,return,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Unexpected Behavior,The bug fix involved modifying the error handling code to only clear BufferError and TypeError. Any other error will now be raised to the caller of np.array.,Within function,Cross-language API call site,"the challenge in detecting this bug lies in the nuanced understanding of error handling in Python and C. It requires knowledge of how Python exceptions are handled in C code, and how they interact with each other.",,
2e697d49a393aba2fcfa9991eaab4f420a58b5d5,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,"When the size argument passed to memcpy is zero, the source and/or destination pointers could be null, which is undefined behavior in C. ",buffer overflow,The bug occur at the locations where memcpy was called without checking if the size argument was zero.,Within function,Non-foreign function call,PyErr_Clear,"foreign, PyErr_Clear",Exception Handling,c to py,Unexpected Behavior,The bug fix involves adding checks before each memcpy call to ensure that the size argument is not zero.,Within function,Conditionals (predicate/conditional expression),"the challenge in detecting this bug lies in the subtleties of the C language's behavior, specifically the undefined behavior when memcpy is called with a size argument of zero and null pointers. ",,
e4edcb7418cd1344e2446b75891c15111db250f1,numpy/numpy,",00 - Bug,component: numpy.core,07 - Deprecation",Security,single,The bug was caused by the ability to set a non-writeable array to writeable even when the array does not own its data and has no base object to check if the memory may be writeable.,permission,The bug occur when attempting to set the writeable flag on an array that does not own its data.,Within function,Non-foreign function call,PyObject_GetBuffer,"foreign, PyObject_GetBuffer",Buffer Protocol,c to py,Unexpected Behavior,The bug fix involves adding checks to prevent setting a non-writeable array to writeable if that array does not own its data and has no base object to check if the memory may be writeable.,Within function,Conditionals (predicate/conditional expression),"The main challenge in detecting this bug is that it involves a subtle misuse of array flags, which may not cause immediate or obvious problems but could lead to unexpected behavior in certain situations. ",,
7efa6192f9393621190e85927a612d11c986718b,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,"The bug was caused by the incorrect handling of the conversion from Python long to long double in numpy. The conversion was initially done through a string, which was not only inefficient but also led to issues on platforms where the precision of long double is higher than double.",Data type error,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,"PyObject_Str, Py_DECREF","foreign, PyObject_Str, Py_DECREF","Objects, Memory Management",c to py,Data Corruption,The bug fix involves modifying the npy_longdouble_from_PyLong function to handle the conversion correctly.,Within function,whole function,"The bug involves the interaction between Python and C, specifically the conversion of data types between the two languages. This requires a deep understanding of both languages and their interoperability. ",,
7db299e59cfb148370b13b62cf5f9f012a446aa5,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,The bug was caused by the function arraymultiter_new not accepting keyword arguments (kwargs). The check for kwargs was incorrectly checking if kwargs was NULL rather than checking if kwargs had a length greater than 0.,logic error,the bug occurred in an if statement,Within function,return,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,unexpected behavior,"The bug fix involved changing the check for kwargs in the arraymultiter_new function. Instead of checking if kwargs was NULL, the check was changed to see if the length of kwargs was greater than 0.",Within function,Conditionals (predicate/conditional expression),The bug was in the C code but it was triggered by the way the function was called from Python.,,
842970f1aaa710b31ebd27427035b58b265e55a8,numpy/numpy,",00 - Bug",Programming,single,The bug arises when the functions unravel_index and ravel_multi_index are given an empty input.,error handling,the bug occurred in an if structure,Within function,function call,"PySequence_Size, PyErr_SetString","foreign, PySequence_Size, PyErr_SetString","Sequence Protocol, Exception Handling",c to py,Type Error,"The bug fix involves adding checks for empty input in the unravel_index and ravel_multi_index functions. If an empty input is detected, an error message is raised. ",Within function,whole function,edge cases like empty inputs might not be immediately obvious and could be overlooked during testing.,,
500b5d9b039ae1cac60280f195be1fa773e676c9,numpy/numpy,",00 - Bug,component: numpy.core,03 - Maintenance",Programming,single,"The bug was caused by missing headers that were supposed to be included before this file, accidentally exported symbols, and the registering types in multiarray.__dict__ were not in the source file that creates the types.",error handling,the bug occurred in header file,Outside function,Preprocessor Directives,PyDict_SetItemString,"foreign, PyDict_SetItemString",Objects,c to py,Unexpected Behavior,"The bug fix involved adding the missing headers that were supposed to be included before this file, fixing the accidentally exported symbols, and moving the registering types in multiarray.__dict__ to the source file that creates the types. ",Within function,whole function,"the bug was not causing a crash or an immediate error, but rather a subtle unexpected behavior, which made it even harder to detect.",,
15b092f5541e80d7c3d0108957406c6f8686aba0,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,The bug was caused by using wrong identifier,variable misuse,The bug occurred after a assiment,Within function,Assignment,PyDict_GetItemString,"foreign, PyDict_GetItemString",Objects,c to py,Unexpected Behavior,The bug fix involves correctly accessing the __array_interface__ offset from the interface dictionary rather than the object itself.,Within function,Cross-language API call site,The challenge in detecting this bug in a multi-language project is that it involves understanding the specific behavior and expectations of Python's __array_interface__ and how it interacts with C code.,,
91140384b61fa7da50743fc769c5a08cce66b893,numpy/numpy,",00 - Bug,component: numpy.dtype",Security,single,The bug was caused by the potential misuse of a PyObject* with a reference count of 0.,Reference count misuse,the bug occurred in an if statement,Within function,function call,"PyMapping_GetItemString, Py_XDECREF","foreign, PyMapping_GetItemString, Py_XDECREF","Mapping Protocol, Memory Management",c to py,Unexpected Behavior,This ensures that the reference count of the PyObject* does not drop to 0.,Within function,Cross-language API call site,Understanding the nuances of Python's reference counting system and how it interacts with C code is crucial.,,
d2517ed1311e12bda3c453dd43f4979b84ef60b3,numpy/numpy,",00 - Bug",Programming,single,The bug was caused by a missing call to PyErr_NoMemory() after a failed memory allocation using PyArray_malloc().,error handling,the bug occurred after a API function and in an if structure,Within function,Cross-language API call site,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Unexpected Behavior,The bug fix involved adding a call to PyErr_NoMemory() after the memory allocation step in the functions,Within function,Cross-language API call site,"It only manifests when memory allocation fails, which might not happen frequently or predictably.",,
ffc044ad702ffb7a4991be1f0766a988259387a1,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,The root cause of the bug is that the pointer 'current' could be NULL if the loop finishes without a break.,Null pointer reference,the bug occurred in an if statement,Within function,function call,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Crash,The bug fix involves adding a NULL check for the 'current' pointer before it is dereferenced.,Within function,Conditionals (predicate/conditional expression),the challenge in detecting this bug lies in the fact that different programming languages have different ways of handling NULL or uninitialized pointers.,,
dea85807c258ded3f75528cce2a444468de93bc1,numpy/numpy,",00 - Bug,component: numpy.core",other,single,"The bug was caused by the need to maintain forward compatibility while keeping the size of the PyArray_ArrFuncs struct fixed. Adding new elements to the end of the structure, a common trick, was not available in this case.",other,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,Unexpected Behavior,The bug fix modifying the sorting algorithm options in the sort and argsort functions. The 'timsort' option was removed from the kind parameter.,Within function,if structure,the challenge lies in maintaining compatibility while evolving the codebase. This requires a deep understanding of the project's design and the implications of changes in one part of the codebase on other parts.,,
3cbc11ac56054ad3ac7461e57433aefe37f2e3e4,numpy/numpy,",00 - Bug,01 - Enhancement,component: numpy.datetime64",Programming,single,The bug was caused by the modulus operation with two timedelta64 operands returning zero in the case of division by zero.,Data type error,the bug occurred in an if structure,Within function,True/false branch,Py_INCREF,"foreign, Py_INCREF",Memory Management,c to py,Data Corruption,. This was done in the inner loop that performs the operations of two other inner loops. The fix also added a divmod operation for two timedelta64 operands.,Within function,whole function,"It requires understanding the specific behavior of operations involving timedelta64 operands, which is not immediately obvious.",,
74f3d07ab0bcfd63f42f62b26eeb6ce68efd4f21,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,The bug was caused by the failure to resolve writeback semantics when arr_insert (used by np.place) failed.,logic error,"the bug occurred in an exceptional control-flow context, which wanted to minus the reference count of some variables here.",Within function,return,Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,Unexpected Behavior,The bug fix involves adding exception handling to resolve writeback semantics when arr_insert fails.,Within function,Cross-language API call site,". In this case, understanding how the failure of a function written in C (i.e., arr_insert) affects the behavior of a Python function (np.place) can be challenging. ",,
2b05f3e38431842ff06df9b2958d22c5a0588767,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,The bug was caused by a double decref (decrement of reference count) of dtype in a failure codepath. This was encountered when hitting the erroring codepaths after calling PyArray_NewFromDescrAndBase which steals a reference to dtype.,invalid pointer,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,"PyDict_GetItemString, Py_DECREF, PyErr_SetString","foreign, PyDict_GetItemString, Py_DECREF, PyErr_SetString","Objects, Memory Management, Exception Handling",c to py,Crash,The bug fix involved ensuring that the reference count to dtype was properly managed to prevent the double decref.,Within function,Cross-language API call site,"The challenge in detecting this bug lies in the fact that it only manifests under specific conditions (i.e., hitting the erroring codepaths after calling PyArray_NewFromDescrAndBase). Furthermore, it involves the misuse of reference count, which can be difficult to track and manage in a multi-language project like NumPy that involves both Python and C.",,
85d64e375f53f6028519d3aaad0b421934dcbe24,numpy/numpy,",00 - Bug,component: numpy.core",other,single,"The function PyArray_AdaptFlexibleDType does not return an error status. The third argument, flex_type, is set to NULL if an error occurs, but the value is not checked after a call to the function.",other,The bug occureed in a non-function(PyArray_AdaptFlexibleDType ) call,Within function,Non-foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,"The fix involves refactoring PyArray_AdaptFlexibleDType to return a meaningful value. The function now returns a PyArray_Descr object instead of void, and the returned object is checked for NULL after the function call. If the returned object is NULL, the function PyArray_CastToType returns NULL to indicate an error.",Within function,Cross-language API call site,"the challenge in detecting this bug lies in the implicit contract between the caller and callee. The function PyArray_AdaptFlexibleDType was expected to set flex_type to NULL on error, and the caller was expected to check this. ",,
1b144ad9d45647960c009ff4fe4e1b18958ff997,numpy/numpy,",00 - Bug,component: numpy.core",Security,multi,The void scalar was missing the clearing logic for the buffer info cache (or storage).,Reference count misuse,The bug occurred when using a variable that was not properly managed with a reference count,Within function,Following a foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,The bug was fixed by adding the clearing logic for the buffer info cache in the void scalar's deallocation function.,Within function,Cross-language API call site,"In this case, the bug was related to memory management in C, which can be difficult to track, especially when the codebase also includes other languages like Python.",,
1b144ad9d45647960c009ff4fe4e1b18958ff997,numpy/numpy,",00 - Bug,component: numpy.core",Security,multi,The void scalar was missing the clearing logic for the buffer info cache (or storage).,memory allocations/releasing,The bug occurred when using a variable that was not properly managed with a reference count,Within function,Following a foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,The bug was fixed by adding the clearing logic for the buffer info cache in the void scalar's deallocation function.,Within function,Cross-language API call site,"In this case, the bug was related to memory management in C, which can be difficult to track, especially when the codebase also includes other languages like Python.",,
9405d2b87e75de1d27b7866c4acf0e18ba3b811a,numpy/numpy,",00 - Bug,component: numpy.fft",Programming,single,"The bug was caused by the inability of the code to handle long doubles (128-bit precision floating point numbers). The code was trying to cast a float type to a complex one, which resulted in a loss of precision.",Data type error,The bug occurred at the points in the code where the functions PyArray_ContiguousFromObject() and PyArray_CopyFromObject() are called.,Within function,Non-foreign function call,Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,Type Error,"The fix involves changing the way arrays are created from the input data. Instead of using PyArray_ContiguousFromObject() and PyArray_CopyFromObject(), the code now uses PyArray_FromAny()",Within function,Cross-language API call site,"the main challenge in detecting this bug is understanding the interaction between Python and C, particularly in terms of data types and casting rules.",,
10bf4c63c0a4c5bb06002158fea16af0d0d79085,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,The root cause of the bug is the failure to handle memory allocation errors,Null pointer reference,The bug occurred after in the function where realloc and malloc are used for memory allocation.,Within function,Assignment,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Abort - Unhandled error,The bug fix involves adding error handling code after each memory allocation operation.,Within function,if structure,the challenge in detecting this bug lies in the fact that memory management and error handling can vary significantly between different programming languages.,,
fd89a4137969b676d4449e2b61ecd7f4c5811d7a,numpy/numpy,",00 - Bug,component: numpy.core",other,single,The bug was caused by incorrect alignment assertions in the low-level stride loops for unsigned integer types.,other,The bug occurred at the alignment assertions in the low-level stride loops.,Within function,assert,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Abort - Unhandled error,The bug fix involved changing the alignment checks in the _aligned_cast functions,Within function,assert,"the alignment of unsigned integer types in C was not correctly handled, which led to the bug.",,
d0aa124350a0b7754f68982e6ab50bf7be49610a,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,The bug was caused by missing free calls in the ufunc_dealloc function,memory allocations/releasing,the bug occurred in the start of a function,Within function,Non-foreign function call,Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,Crash,The bug fix involved adding free calls for function,Within function,function call,"The main challenge in detecting this bug is that memory leaks can be difficult to detect in multi-language projects. They may not cause immediate problems, and the symptoms (increased memory usage over time) can be subtle and easily overlooked.",,
a22bb0e4dd4265216128cfb4796730d1df2b5d94,numpy/numpy,",00 - Bug,component: numpy.core,Patch",Programming,single,The bug is caused by the non-symmetrical behavior of the dot() function for scalar multipliers when one of the objects is a matrix of objects.,function misuse,The bug occurred after Cross-language parsing time,Within function,Following a foreign function call,PyTuple_GET_ITEM,"foreign, PyTuple_GET_ITEM",Objects,c to py,Data Corruption,The bug fix involves modifying the dot() function to handle the case where a scalar is the first argument and a matrix of objects is the second.,Within function,Conditionals (predicate/conditional expression),The challenge in detecting this bug is understanding the expected behavior of the dot() function in all possible scenarios.,,
ca27396b2f32befb7465c4a245329716cb212b80,numpy/numpy,",00 - Bug,16 - Development,06 - Regression",Programming,single,The function no longer correctly interprets the __array_interface__ of a custom float object.,logic error,The bug occured in a non-function(_array_typedescr_fromstr) call and a Cross-language function call (PyString_AS_STRING),Within function,Cross-language API call site,"PyUnicode_Check, Py_DECREF","foreign, PyUnicode_Check, Py_DECREF","Objects, Memory Management",c to py,Unexpected Behavior,"The function needs to correctly interpret the __array_interface__ of custom float objects, ensuring that it returns an array of the correct type.",Within function,Preprocessor Directives,The main challenge in detecting this bug is the cross-language nature of the Numpy library.,,
5268fe6ecd5637169bffe2dfd1fa7af5dbda4862,numpy/numpy,",00 - Bug,component: numpy.distutils",Programming,single,The bug was caused by the type_num being considered in the hash input for dtype comparison in NumPy. This led to equivalent dtypes with different type_num not hashing equally,Logic Error,The bug occurred at calling the Cross-language API,Within function,Cross-language API call site,Py_BuildValue,"foreign, Py_BuildValue",Parsing arguments,c to py,Unexpected Behavior,The bug fix involved modifying the dtype hashing function to ignore type_num. This was done to ensure that equivalent dtypes with different type_num hash equally.,Within function,argument of function,the challenge lies in understanding the nuances of dtype handling across different languages and how they interact with each other.,,
ae3dd3304bc76dfe9f9514c922669feeb50e3073,numpy/numpy,",00 - Bug,component: numpy.lib",Programming,single,"The bug was caused by incorrect handling of scalar types in function. The function was not correctly identifying and handling different scalar types, leading to incorrect behavior when dealing with integer arrays",special case,"The bug was not a runtime error, so it doesn't occur at a specific location in the code.",Outside function,Outside any function/global area,"PyFloat_Check, Py_DECREF","foreign, PyFloat_Check, Py_DECREF","Objects, Memory Management",c to py,Unexpected Behavior,The bug fix involved modifying the function to correctly identify and handle different scalar types.,Within function,block,the challenge in detecting this bug lies in the complexity of handling different data types across different parts of the code. It requires a deep understanding of how different data types are handled and converted in different scenarios,,
a1e7be3cb49577d77831e2246f39bb80acd5a22f,numpy/numpy,",00 - Bug,component: Other",Programming,single,"new feature, ",Logic Error,The bug was caused by the function PyArray_NewFromDescr not updating the flags when the strides parameter was not NULL. Thwas wassue was more prominent as PyArray_NewLikeArray started using the function with a non-NULL strides parameter more frequently.,Within function,True/false branch,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,The bug was fixed by adding a condition to check if strides is not NULL and then updating the flags accordingly.,Within function,if structure,"the challenge in detecting this bug lies in the interaction between different parts of the codebase. The bug surfaced due to the increased usage of PyArray_NewLikeArray function with a non-NULL strides parameter, which required a deep understanding of the codebase and the interactions between different functions. Additionally, the bug was in the C portion of the codebase, which may not be as familiar to developers primarily working in Python.",,
8598315e41ed38faf3fb71cdc7c6f62067a9b2e8,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,"reference leak & NULL reference, ",Reference count misuse,The bug occurred at non-foriegn function call,Within function,Cross-language API call site,PyObject_Print,"foreign, PyObject_Print",Objects,c to py,Crash,"The fix involves modifying the copyswap function call. Instead of passing &value directly, an array value[4] is created and its address is passed to the function.",Within function,function call,"the challenge in detecting this bug lies in the interaction between Python and C. Python's garbage collector handles memory management, but C does not have a built-in garbage collector. Therefore, when using C extensions in Python, as in the case of NumPy, developers must manually manage memory.",,
577dbbd844b60958a59e062dae428a34a9c3644f,numpy/numpy,",00 - Bug,Priority: high,component: numpy.core",Programming,single,"new feature, The bug is caused by the fact that PyArg_ParseTuple(""s#"", ...) does not accept objects with the new buffer interface if they have bf_releasebuffer defined.",API misuse,"The bug was to occur in the code where PyArg_ParseTuple(""s#"", ...) was called with an object that has bf_releasebuffer defined.",Within function,Non-foreign function call,PyObject_ClearWeakRefs,"foreign, PyObject_ClearWeakRefs",Objects,c to py,Crash,"The bug fix involves not defining bf_releasebuffer at all, and releasing any info associated with the buffer interface when the array or its descriptor is deallocated.",Within function,block,"It requires understanding of both Python and C, as well as the interaction between them, specifically the buffer interface.",,
914c498abefb4f65e160cdf6b030ff8efe8b975c,numpy/numpy,",00 - Bug,component: Other",Programming,single,"new feature, The bug was caused by the function ufunc_generic_call in the NumPy library. It was returning a NotImplemented error for all cases where errval == -1, which was not the intended behavior. ",special case,"The bug occur in the ufunc_generic_call function, specifically in the error handling block where errval == -1.",Within function,True/false branch,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Unexpected Behavior,"The fix involved modifying the error handling block in the ufunc_generic_call function. The code now checks if the ufunc has 2 inputs and 1 output, and only in this case does it return NotImplemented. For all other cases, it raises a NotImplementedError.",Within function,True/false branch,"Detecting this bug would require a deep understanding of the intended behavior of the ufunc_generic_call function and the specific use cases it handles. In a multi-language project, such bugs can be particularly challenging to detect due to the complexity of interactions between different parts of the codebase, each potentially written in a different language.",,
c355e7162b6b170372471266d3f913a07d5561e2,numpy/numpy,",00 - Bug,component: numpy.lib",Programming,single,"new feature, The bug was caused by the fact that the code allowed duplicate entries for 'name' and 'title'. This was not checked properly in the original code, leading to potential conflicts and errors.",Logic Error,The bug occur at Cross-langauge API.,Within function,Cross-language API call site,"PyDict_SetItem, Py_DECREF","foreign, PyDict_SetItem, Py_DECREF","Objects, Memory Management",c to py,Unexpected Behavior,"The bug fix involves adding a check to ensure that the 'title' is not already used as a 'name' or 'title'. If it is, an error is raised.",Within function,Cross-language API call site,"the use of Python's C API can be complex and error-prone, making bugs harder to detect and fix.",,
85995f94d4fcedc96ec2647577a8dd1375fff839,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,"memory leak due to unfreed python objects, ",memory allocations/releasing,The bug occur in the sections of the code where the casting of objects was happening.,Within function,Assignment,Py_CLEAR,"foreign, Py_CLEAR",Memory Management,c to py,Crash,"The bug fix involves adding a block of code that checks if casting is needed and if it is from a non-object array. If both conditions are met, it iterates over the buffer size and clears the objects in the cast buffer.",Within function,if structure,"the challenge in detecting this bug lies in the interaction between Python and C. Python's garbage collection is based on reference counting, and C extensions must carefully manage object lifetimes to avoid leaks or crashes.",,
fd0866ffc7ca4c3d843b156c9a706b1a3e1ad67d,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,"new feature, The bug was caused by the incorrect initialization of the block of data corresponding to the identity for the ufunc used during reduceat with a buffer.",special case,The bug occurred at if statement,Within function,return,"PyErr_Format, Py_DECREF ","foreign, PyErr_Format, Py_DECREF ","Exception Handling, Memory Management",c to py,Unexpected Behavior,The bug was fixed by adding an additional condition to the if statement that checks the method of the loop.,Within function,Conditionals (predicate/conditional expression),"the bug is located in a complex part of the codebase (ufuncs), which requires a deep understanding of both the code and the mathematical operations it performs.",,
1a8afce8a2b2a6e563a159272ab51c5ff99ffab2,numpy/numpy,",00 - Bug,component: Other",Programming,single,"unicode error, The bug was caused by a discrepancy in the handling of string and unicode arrays in the NumPy library. When comparing these two types of arrays, the code did not correctly handle the difference in element sizes, leading to incorrect comparisons.",Data type error,"The bug occur in the if statement, specifically when the type_num of the self and other objects are PyArray_STRING and PyArray_UNICODE respectively",Within function,Cross-language API call site,Py_INCREF,"foreign, Py_INCREF",Memory Management,c to py,Unexpected Behavior,"The fix involves creating a new PyArray_Descr object unicode from the descriptor of the other object when self is a string and other is unicode, or from the descriptor of self when self is unicode and other is a string.",Within function,Cross-language API call site,The main challenge in detecting this bug is the nuanced understanding of the differences between string and unicode data types and how they are handled in different programming languages.,,
97ffd1eb580f2a1969133ce56e324d18ff1608a9,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,The root cause of the bug is an integer overflow in the size calculation of the array.,integer overflow,The bug occur at the size calculation of the array in the code.,Within function,Assignment,"PyErr_SetString, Py_DECREF ","foreign, PyErr_SetString, Py_DECREF ","Exception Handling, Memory Management",c to py,Crash,"The bug fix involves checking for potential integer overflow during the size calculation of the array. If the dimension of the array (dim) is greater than the maximum allowed size (largest), an error is raised.",Within function,Conditionals (predicate/conditional expression),"the challenge in detecting this bug lies in the subtlety of the issue. Integer overflow bugs can be difficult to detect because they may not always lead to an immediate crash or noticeable error. They can also be influenced by the specific architecture and compiler behavior, making them harder to reproduce consistently.",,
a0e082a087e9667e3805d3be859958a292e8f336,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,"memory error on operating multi-iter object, ",buffer overflow,The bug occurred in if,Within function,Cross-language API call site,"PyObject_Init, PyErr_Format, Py_DECREF","foreign, PyObject_Init, PyErr_Format, Py_DECREF","Objects, Memory Management, Exception Handling",c to py,Crash,The bug fix involved changes in the PyArray_Choose function in multiarray/src/multiarraymodule.c. The changes mainly involve the replacement of certain code blocks with new ones that handle memory and data operations more accurately.,Within function,whole function,"the challenge in detecting this bug lies in the interaction between Python and C. Python is a high-level language that handles memory management automatically, while C is a low-level language that requires manual memory management. This difference can lead to difficulties in tracking down bugs related to memory management, especially in projects that involve both languages.",,
ebf8dce3a385f9da5b1e769cb1c41f8f928dfedf,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,"ref-count leak, ",Reference count misuse,The bug occur in the section of the code where the function PyArray_CanCoerceScalar was defined.,Within function,True/false branch,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,The bug is fixed by adding a Py_DECREF(from) statement in the if condition inside the while loop.,Within function,True/false branch,"the main challenge in multi-language projects is the need to understand the semantics and idioms of multiple programming languages. In this case, the bug is in C code that is part of a Python project, and understanding the bug requires knowledge of both C and Python's C API.",,
ae31c236681a2f2c652bd63c4e568f35085248c5,numpy/numpy,",00 - Bug,component: Other",Security,single,"ref-count leak, ",Reference count misuse,The bug  occur in the part of the code where the log(0.0) function was called during random number generation.,Within function,True/false branch,"PyErr_SetString, Py_DECREF ","foreign, PyErr_SetString, Py_DECREF ","Exception Handling, Memory Management",c to py,Crash,The bug is fixed by adding a condition to check if obj is not equal to ret after the PyArray_FromArray function is called.,Within function,Conditionals (predicate/conditional expression),the challenge in detecting this bug in a multi-language project would be understanding the context in which these changes are made.,,
b2bbe268dd106b5c8252cc0d9ebf31b26dc19c5b,numpy/numpy,",00 - Bug,component: Other",other,single,"incorrect code generation, ",other,The bug occurred at if statement,Within function,True/false branch,"PyObject_SetAttr, Py_DECREF ","foreign, PyObject_SetAttr, Py_DECREF ","Objects, Memory Management",c to py,Unexpected Behavior,The bug is fixed at if,Within function,True/false branch,the challenge in detecting this bug could be related to the interaction between Python and C,,
6e6c5c4fdb6548ef6eae953ce453a1a89c290fc1,numpy/numpy,",00 - Bug,component: Other",Security,single,miss boundary check,special case,The bug  occur at the line where elsize is assigned the value of dtype->elsize.,Within function,Assignment,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Unexpected Behavior,The fix involves adding a check to see if elsize is 0 after it is assigned the value of dtype->elsize.,Within function,if structure,the challenge in detecting this bug lies in the fact that different languages have different ways of handling data types and iterators.,,
dd868d86c0080a2f73341fdd8da960c2af6318d9,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,meak leak caused by cross-language flow,memory allocations/releasing,The bug  occur at the line if (PyArray_ISNUMBER(mp) && PyArray_ISNUMBER(out)).,Within function,Cross-language API call site,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Crash,The bug is fixed by modifying the condition check in the code.,Within function,Cross-language API call site,"The challenge in identifying this bug in a multi-language project context is that it's a performance issue rather than a functional one. The bug was related to speed and not a feature malfunction, which makes it harder to detect, especially in a multi-language environment where different languages have different performance characteristics.",,
be077dafb8ed2b9dc30f925868612cf7d7f56a2b,numpy/numpy,",00 - Bug,component: numpy.distutils",other,single,"clean up compiling errors, ",other,The code block starting with if (PyArray_ISALIGNED(dest) && !PyArray_ISFLEXIBLE(dest)) was the problematic area,Within function,Non-foreign function call,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,The bug was fixed by adding a new macro definition in numpy/core/include/numpy/ndarrayobject.h file: #define PyArray_SAFEALIGNEDCOPY(obj) (PyArray_ISALIGNED(obj) && !PyArray_ISVARIABLE(obj)).,Within function,function call,The challenge in detecting this bug in a multi-language project context is that it's deeply rooted in the specific behavior of Python and NumPy.,,
e26b067d39b66461018632c32fcd6e31df57ae9a,numpy/numpy,",00 - Bug,component: numpy.core",Security,single,"clean up compiling warnings, ",Reference count misuse,The bug occurred at the memory management cross-language API,Within function,Cross-language API call site,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,The bug add some more reference count management API,Within function,Cross-language API call site,"the bug is related to memory management, which is often a complex aspect of programming, especially in languages like C that don't have automatic garbage collection.",,
86a257e385afd6914411215d1ff3feb9805b0ac2,numpy/numpy,",00 - Bug,Priority: high,component: Other",Security,single,meak leak caused by cross-language flow,Reference count misuse,The bug occurred at if statement,Within function,True/false branch,Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,Crash,The bug was fixed by adding proper memory management for the errobj object.,Within function,Cross-language API call site,detecting such bugs can be challenging due to the need to understand and track memory management across different languages.,,
4eb3bf56a0d3de3fb67fe6d3fcbd55e798ea4fca,numpy/numpy,",00 - Bug",Programming,single,"logic error, ",logic error,The bug occurred at if statement,Within function,True/false branch,PyDataType_ISOBJECT,"foreign, PyDataType_ISOBJECT",Objects,c to py,Unexpected Behavior,The bug change the True/False branch,Within function,True/false branch,"Understanding the interaction between these languages and tracing the bug's origin would require proficiency in both, making it a detection challenge.",,
6ec42819ccd70a406f6be8c6f45ae41fd4851f5f,numpy/numpy,",00 - Bug",other,single,"code cleanup, ",other,The bug ioccur in the function npy_ldexp at the line where the variable m is calculated.,Within function,Conditional (predicate/conditional expression),PyArg_ParseTuple,"foreign, PyArg_ParseTuple",Parsing arguments,py to c,Unexpected Behavior,The bug was fixed by replacing the m calculation by new calculation method,Within function,Conditionals (predicate/conditional expression),"The bug is related to memory management, a common issue in C but less common in Python due to its garbage collector. This discrepancy in language features can make it difficult to identify such bugs, especially for developers primarily familiar with Python.",,
6d8010c4654cbc7e9a04495a4401548fa47e332c,numpy/numpy,",00 - Bug",Programming,single,"incorrect length calculation of array dimenson, ",special case,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,Unexpected Behavior,This change corrects the string to unicode conversion process by considering the string itemsize as four times as large instead of twice.,Within function,Conditionals (predicate/conditional expression),"challenge here is the need to understand the interaction between these languages, particularly in terms of data type conversion and memory management.",,
f89443c39616bd4ad13cb9152c28acc15c6500be,numpy/numpy,",00 - Bug",Programming,multi,"incorrect length calculation of a Python object, ",API misuse,The bug occurred at the cross-langauge API,Within function,Cross-language API call site,PyDict_Size,"foreign, PyDict_Size",Objects,c to py,Type Error,The PyTuple_GET_SIZE change to PyDict_Size,Within function,Cross-language API call site,"the bug is subtle and related to how a dtype variable reports its length, which requires specific domain knowledge about the project's internals.",,
f89443c39616bd4ad13cb9152c28acc15c6500be,numpy/numpy,",00 - Bug",Programming,multi,"incorrect length calculation of a Python object, ",variable misuse,The bug occurred at return statement,Within function,Cross-language API call site,PyDict_Size,"foreign, PyDict_Size",Objects,c to py,Type Error,The self->fields attribute correctly reports the length of a dtype variable.,Within function,Cross-language API call site,"the bug is subtle and related to how a dtype variable reports its length, which requires specific domain knowledge about the project's internals.",,
8175ff79e0a94f0806dd174ebb09aec8652764ab,numpy/numpy,",00 - Bug,component: numpy.core,57 - Close?",other,single,Offset is not updated when slicing memmaps,other,The bug occurred at the cross-langauge API,Within function,Cross-language API call site,Py_INCREF,"foreign, Py_INCREF",Memory Management,c to py,Unexpected Behavior,"The bug fix by modifying the handling of certain variables. Specifically, the lines that were creating and handling __pyx_2 and __pyx_4 variables were removed or modified.",Within function,Cross-language API call site,The challenge in detecting this bug in a multi-language project arises from the need to understand the interaction between these languages.,,
d481013f47dc92470e9445aec1fb373a09686f5e,google/jax,",contributions welcome,better_errors",other,single,try to execute instructions  that do not exists,other,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,Py_INCREF,"foreign, Py_INCREF",Memory Management,c to py,Unexpected Behavior,The bug is fixed by adding a check for the __FMA__ macro in the CheckCpuFeatures function,Within function,whole function,"The challenge in detecting this bug in a multi-language project could stem from the fact that it involves low-level, hardware-specific functionality (CPU features), which might not be immediately evident in higher-level languages.",,
2fd2e07342e32df77d5db6ea908fbefad58af935,kovidgoyal/kitty,",bug",Programming,single,Mismatching definition of function and its declaration,Data type error,The bug occurred in the code is in the parse_sgr function declaration and the apply_sgr function where params is defined and used.,Within function,Assignment,PyUnicode_READY,"foreign, PyUnicode_READY",Objects,c to py,Unexpected Behavior,The bug is fixed by changing the type of params from unsigned int to int.,Within function,assignment,"the interaction between different languages could complicate the debugging process, as the error could be incorrectly attributed to inter-language communication rather than a simple type mismatch.",,
0df9a5d5c53022a7e4588593e2782e8a8eca6de9,kovidgoyal/kitty,",bug",Programming,single,python compatability issue,compatibility,The bug occurred at the deprecated API PySys_AddXOption,Within function,True/false branch,Py_DecodeLocale,"foreign, Py_DecodeLocale",Operating System Utilities,c to py,Unexpected Behavior,The bug was fixed by replacing the deprecated PySys_AddXOption function with the PyConfig.xoptions method.,Within function,if structure,"the detection challenge for Python compatibility issues lies in identifying instances where code written in one language (e.g., Python) is interacting with or impacting code written in other languages.",,
a13a7b82d4664c767575097c4a60c0b5fcd1098a,scipy/scipy,",defect,scipy.interpolate",Security,single,"The bug was caused by an integer overflow in the bivariate splines in fitpackmodule.c. This overflow occurred when the product of mx*my exceeded the maximum value that could be held by the integer type used (F_INT), which could be either npy_int64 or npy_int32 depending on the system.",integer overflow,"The bug occur in the fitpack_bwaspev function, specifically at the line where the product mx*my was calculated and assigned to mxy",Within function,True/false branch,PyErr_Format,"foreign, PyErr_Format",Exception Handling,c to py,Data Corruption,The bug was fixed by adding a check to ensure that the product mx*my does not exceed the minimum of the maximum NPY_INTP value and the maximum F_INT value.,Within function,Conditionals (predicate/conditional expression),the detection challenge lies in identifying potential integer overflow issues that can occur due to different integer types used across various systems.,,
9fede9489d98707240d0e7213104bc617daa4c75,scipy/scipy,",defect,scipy.special,C/C++",Security,single,"The bug was caused by an increase in the reference count of scipy.special when a SpecialFunctionError was raised, which led to a memory leak.",Reference count misuse,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Crash,The bug was fixed by adding a DECREF (decrement reference count) for the scipy_special object before exiting the sf_error() function.,Within function,Cross-language API call site,tracing the memory leak across language boundaries and understanding the impact on the overall system's performance may present a unique challenge for developers working with multi-language projects.,,
c320f7e296651cb624857ec6d88df8fc10fd0bb1,scipy/scipy,",defect,scipy.special",Programming,single,The bug is caused by a loss of precision in the erfinv(x) function for small x values.,special case,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,cephes_isnan,"helper, cephes_isnan",Objects,c to py,Unexpected Behavior,The bug is fixed by implementing a regression test for the erfinv(x) function to handle small x values more accurately.,Within function,if structure,"It requires analyzing the code and understanding the context of the function usage to identify potential issues, which may vary in different languages due to syntax and coding patterns.",,
60dc9730d5652f0632cd43caef437f01a734e374,scipy/scipy,",defect,enhancement",Programming,single,The bug was caused by the incorrect calculation of zoom factors in the zoom function.,function misuse,in the calculation of the zoom variable.,Within function,Cross-language API call site,PyArg_ParseTuple,"foreign, PyArg_ParseTuple",Objects,py to c,Unexpected Behavior,The fix involved modifying the calculation of the zoom variable to account for the full pixel extent.,Within function,Cross-language API call site,challenge would be identifying inconsistencies or differences in how zoom factors are calculated across different programming languages.,,
8fa4b7364d98659dd8fe28727f60d99a14b95850,scipy/scipy,",defect,scipy.ndimage",Programming,single,This results in values outside the original image extent having an unexpected DC offset.,special case,The bug occur in the part of the code where was initially called when mode = 'nearest'. Thwas was where the fractional pixel offset in the cc variable was lost due to clipping.,Within function,function call,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Unexpected Behavior,The bug is fixed by using the unmapped cc coordinate directly for setting the start point of the interpolation kernel.,Within function,Conditionals (predicate/conditional expression),"detection challenge in careful examination of image processing algorithms, boundary handling methods, and data flow across different languages and modules.",,
3f4396e7c8e21ea0c432c1747b221e64c162b6f5,scipy/scipy,",defect,scipy.signal",Security,single,The bug was due to a lack of input validation,Null pointer reference,The bug occur when the sepfir2d function was called with invalid inputs.,Within function,True/false branch,PyArray_SimpleNew,"helper, PyArray_SimpleNew",Objects,c to py,Crash,The bug was fixed by adding input validation to the sepfir2d function.,Within function,Conditionals (predicate/conditional expression),"Each language may have its own unique set of validation functions and rules, making it challenging to maintain uniformity and identify potential vulnerabilities due to inconsistencies.",,
e2091e9e4be2dffed8c6535547e8519dc002fa74,scipy/scipy,",defect,scipy.interpolate",Security,single,The bug was caused by a segmentation fault in the splprep function when knots were specified for task=-1.,invalid pointer,"The bug occurred at the line tck, u = interpolate.splprep([x, y], task=-1, t=uknots).",Within function,True/false branch,Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,Crash,The fix involves handling the case where knots are specified for task=-1 in the splprep function to prevent segmentation faults.,Within function,Conditionals (predicate/conditional expression),detection challenge to identify this bug lies in ensuring consistent error handling and reporting mechanisms across different languages.,,
ae34ce4835949a8310d7c3d7bcb4a55aafd11f4f,scipy/scipy,",defect,scipy.ndimage",Programming,single,The bug was caused by the incorrect handling of the nan_policy parameter,special case,The bug occurred at the nan_policy parameter,Within function,Conditional (predicate/conditional expression),PyErr_Format,"foreign, PyErr_Format",Exception Handling,c to py,Unexpected Behavior,"The fix involved modifying the handling of the nan_policy parameter to correctly deal with NaN values,",Within function,if structure,detection challenge in identifying this bug lies in ensuring consistent and correct handling of the parameter across different programming languages.,,
ee68ea834e7d59cdcd7541c33a1019047c6c18bc,scipy/scipy,",defect,scipy.special",other,single,The bug was caused by an incorrect assumption,other,"The bug occur at the line return a_view[mode], counts[mode] in the mode function",Within function,Non-foreign function call,sf_error,"helper, sf_error",Exception Handling,c to py,Unexpected Behavior,"The fix involved adding a check at the beginning of the function to return appropriate values (np.nan, np.nan) when the input array is empty.",Within function,function call,Since different programming languages may handle assumptions differently,,
1984f97749a355a6767cea55cad5d1dc6977ad5f,scipy/scipy,",defect",Security,single,The bug was caused by the incorrect implementation of the __array_function__ protocol,Data type error,Thwas was where the numpy functions are called with sparse matrix arguments.,Within function,Conditional (predicate/conditional expression),npy_isnan,"helper, npy_isnan ",Objects,c to py,Type Error,The bug was fixed in the scipy.sparse module by implementing the __array_function__ protocol correctly.,Within function,Conditionals (predicate/conditional expression),"multi-language projects involve integrating components written in various languages, detecting this bug requires ensuring compatibility and proper handling of array functions across all languages.",,
7b9111c0bc32e136cf64829a483eee58b6d6bf1d,scipy/scipy,",defect,scipy.interpolate",Security,single,"This was due to improper memory management in the C code, where allocated memory was not being correctly deallocated.",Reference count misuse,The bug in the sections of code where memory was allocated (using PyArray_SimpleNew) but not properly deallocated in certain conditions.,Within function,Conditional (predicate/conditional expression),Py_XDECREF,"foreign, Py_XDECREF",Memory Management,c to py,Crash,The fix involved adding proper deallocation of memory (using Py_XDECREF and setting to NULL) in the necessary sections of the code.,Within function,True/false branch,detection challenge is identifying memory management issues consistently across different programming languages.,,
89acad947b34e3e906072adf383b8021935f4d3d,scipy/scipy,",defect,scipy.ndimage",Security,single,The bug arises due to undefined behavior when converting from a result stored in a double float variable to an unsigned integer value.,Data type error,The bug occur in the conversion process where the double float variable was converted to an unsigned integer value.,Within function,Non-foreign function call,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Type Error,"The bug is fixed by introducing a new macro, CASE_FILTER_OUT_SAFE, which adds an additional cast from floating point to signed integer",Within function,function call,detection challenge for this bug lies in identifying potential type conversion mismatches and undefined behavior when converting between floating-point and integer data types.,,
309247fb9b30ec0de36d7d281c89cf42e3b77f5f,scipy/scipy,",defect,scipy.special",other,single,The bug was in the implementation of the upper/lower incomplete gamma functions for infinite values of a.,other,"The bug occur in the code where the functions sc.gammaincc(a, x) and sc.gammainc(a, x) are defined and used.",Within function,return,npy_isinf,"helper, npy_isinf",Objects,c to py,Unexpected Behavior,"The bug was fixed by correctly handling the case when a is infinite in the functions sc.gammaincc(a, x) and sc.gammainc(a, x).",Within function,if structure,validating the correctness and robustness of the implementation across languages becomes crucial for effective bug detection and resolution.,,
085330f94e1ee9cbf534564a35f4cf3019f8bb25,scipy/scipy,",defect,scipy.optimize",Security,single,"when calling these root finders, the tuple of arguments to pass to the underlying function is created once, and only the first entry is modified on subsequent calls.",invalid pointer,The bug occur in the C-implemented root finders in scipy.optimize when they are passed a function wrapped with functools.lru_cache.,Within function,Cross-language API call site,"PyTuple_GetItem, Py_DECREF ","foreign, PyTuple_GetItem, Py_DECREF ","Objects, Memory Management",c to py,Crash,"The bug is fixed by constructing a new argument tuple each time the underlying function is called, instead of modifying the first entry of the same tuple on subsequent calls.",Within function,if structure,"The challenge in detecting this bug in a multi-language project lies in the interaction between Python and C, which requires understanding of both Python and C programming paradigms.",,
50d57a81575927cf991d89cb28d4aa09be152606,scipy/scipy,",defect,scipy.special",Programming,single,The ndtri function in the SciPy library was not correctly handling inputs outside of its domain of definition.,special case,"The bug occur in the ndtri function when it was called with inputs outside the range of [0, 1].",Within function,return,mtherr,"helper, mtherr",Objects,c to py,Unexpected Behavior,The bug was fixed by modifying the ndtri function to return NaN for inputs outside its domain of definition.,Within function,Conditionals (predicate/conditional expression),detection challenge in multi-language projects is to identify cases where functions or libraries do not handle inputs outside their domain of definition gracefully.,,
a790deb61f2dd45f2dbfa2345d6b2c4fe7698b36,scipy/scipy,",defect,scipy.stats,enhancement,scipy.special",Programming,single,The bug was caused by the 'smirnovci' function not supporting the input types and the inputs could not be safely coerced to any supported types according to the casting rule 'safe'.,Data type error,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,npy_isnan,"helper, npy_isnan ",Objects,c to py,Type Error,The fix involved rewriting the algorithms in the Kolmogorov-Smirnov statistics package to improve numerical precision and handle convergence failures.,Within function,whole function,detection challenge in this bug for multi-language projects is to identify unsupported input types and safely handle type coercion.,,
0aee4a24bedb154d07a3b5ba016a385b1ac2910c,scipy/scipy,",defect,scipy.integrate",Security,single,The bug was caused by the code not handling repeated t values correctly,Initialization,The bug occur in the odepack_odeint function where the t values are processed and the LSODA function was called.,Within function,Assignment,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Unexpected Behavior,The bug was fixed by adding code to count how many times the initial t value occurs and only calling the LSODA function when necessary.,Within function,if structure,detection challenge would be identifying inconsistencies in handling values across different programming languages.,,
cf14675f5bf0fc6bd495fd23f35246c5b2f79a4b,scipy/scipy,",defect,scipy.ndimage",Programming,single,The bug was caused by the lack of support for certain data types in the C language.,Data type error,The bug would occurwhen the function NI_InitLineBuffer was called with an array of unsupported data type.,Within function,Conditional (predicate/conditional expression),PyErr_Format,"foreign, PyErr_Format",Exception Handling,c to py,Unexpected Behavior,The bug was fixed by adding a check for the data type of the input array before processing.,Within function,switch structure,detection challenge would be to identify data type compatibility issues across different programming languages.,,
ef694bae0eddd1b0a167a579dd016158edccd94a,scipy/scipy,",defect,scipy.special",Programming,single,The bug was caused by the improper handling of nan values in the input arguments of certain functions.,special case,The bug could occur in any of the functions when they receive nan values as input,Within function,True/false branch,npy_isnan,"helper, npy_isnan ",Objects,c to py,Unexpected Behavior,The bug was fixed by adding checks for nan values in the input arguments of the functions.,Within function,Conditionals (predicate/conditional expression),detection challenge would involve identifying and addressing the inconsistent handling of NaN (Not-a-Number) values across different programming languages,,
1106f4489badad63c20ab03d8513c58ebc34c2db,scipy/scipy,",defect,scipy.special",other,single,"The bug is related to the function special.fdtri(1, 1, 0.5). This function sometimes returns nan on i686 systems.",other,"The bug occur in the special.fdtri(1, 1, 0.5) function call",Within function,return,mtherr,"helper, mtherr",Objects,c to py,Unexpected Behavior,The bug fix at conditional,Within function,Conditionals (predicate/conditional expression),detection challenge is ensuring platform independence and thorough cross-platform testing are crucial to detect and fix such issues effectively.,,
c226774f0f1371401609e9fcba41ecf541136123,scipy/scipy,",defect,scipy.special",Performance,single,The bug was caused by incorrect handling of the endianness of output arrays,heavy memory operation,"The bug was to occur in the functions NA_InputArray, NA_OutputArray, and NA_IoArray",Within function,True/false branch,Py_INCREF,"foreign, Py_INCREF",Memory Management,c to py,Performance issue,The bug was fixed by simplifying the code and removing a lot of unused functionality.,Within function,True/false branch,detection challenge lies in identifying inconsistencies in endianness handling across different programming languages.,,
55ff7a6a3edf6127622bcea161a405dfaf2644f6,scipy/scipy,",defect,scipy.integrate",Programming,single,The bug was caused by an improper return of error to Fortran from the ode_jacobian_function.,logic error,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,Py_DECREF,"foreign, Py_DECREF",Memory Management,c to py,Unexpected Behavior,"The fix involved ensuring that the function properly returns errors to Fortran, particularly when multiple exceptions are thrown from C-extensions in Python 3.",Within function,assignment,detection challenge in multi-language projects for identifying this bug lies in seamlessly detecting and handling errors propagated across language boundaries.,,
63d5c2bdc93c2da03215774832a1c4ce1b790166,scipy/scipy,",defect,scipy.ndimage",other,single,The bug was caused by the incorrect use of the numpy.iscomplexobj function.,other,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,Py_FatalError,"foreign, Py_FatalError",Operating System Utilities,c to py,Unexpected Behavior,The numpy.iscomplexobj function was replaced with a new condition that checks if the input is a complex number by directly comparing the imaginary part with zero.,Within function,whole function,detection challenge would involve identifying instances where the incorrect use of the function occurs across different languages and codebases.,,
88d625fc451d3714e640bbec693bb31abb6a05f5,scipy/scipy,",defect,scipy.ndimage",Programming,single,"scipy.stats module did not handle the case where the input array contained nan values, leading to incorrect results.",Data type error,"The bug was  to occur in the rank function in the scipy.stats module, when the function was called with an input array that contains nan values.",Within function,Assignment,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Type Error,The fix involved adding a check for nan values in the input array and handling them appropriately to ensure the correct results are returned.,Within function,assignment,detection challenge to identify this bug is ensuring consistent handling of NaN (Not a Number) values across different programming languages.,,
e16b190160fb15bb9bf590236c9e739c360ab320,scipy/scipy,",defect,scipy.ndimage",Programming,single,The bug was caused by variable declarations being preceded by code due to a rebase.,initialization,"the variable declarations struct pairs, *ring, *minpair, *end, *last are preceded by code.",Within function,Assignment,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Unexpected Behavior,"The fix involves moving the variable declarations to the beginning of the block, before any executable statements.",Within function,assignment,detection challenge in multi-language projects for identifying the bug caused by variable declarations being preceded by code due to a rebase lies in understanding and analyzing the code changes during the rebase process across different languages.,,
77b133df433a7e37e01023a88132d7ba47faac77,scipy/scipy,",defect,scipy.sparse",Programming,single,The bug appears to be related to the handling of unaligned sparse matrix arrays in the SciPy library.,function misuse,The bug would  occur in the functions NRFormat_from_spMatrix and NCFormat_from_spMatrix where the conditions for the sparse matrix arrays are checked.,Within function,Cross-language API call site,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Unexpected Behavior,The fix change the cross-langauge API,Within function,Cross-language API call site,detection challenge for identifying the bug related to unaligned sparse matrix arrays would be coordinating efforts and ensuring consistent understanding across different programming languages,,
b618db4a0e7acf50c5268011beb5bea4c6e41432,scipy/scipy,",prio-normal,defect,Migrated from Trac,scipy.sparse",Programming,single,"The bug was in the Cephes code for the kn function, which had issues for large orders.",Data type error,The bug was  to occur in the kn function,Within function,True/false branch,cbesk_wrap,"helper, cbesk_wrap",Objects,c to py,Unexpected Behavior,a new function cbesk_wrap_real_int was added and the cbesk_wrap_real function was updated to handle underflow cases.,Within function,True/false branch,detection challenge in identifying this bug lies in ensuring consistent behavior across different programming languages.,,
d4e3e60a13bbca43e0f9d7466703e4d438320d4d,scipy/scipy,",prio-normal,defect,Migrated from Trac,scipy.stats",other,single,The bug caused by using wrong value,other,The bug occurred at if branch,Within function,True/false branch,mtherr,"helper, mtherr",Objects,c to py,Unexpected Behavior,The fix at the if branch,Within function,True/false branch,detection challenge for identifying bugs caused by using wrong values is the inconsistency in data types,,
2a2d8be5f52481938c817eb7150fe7152958853d,scipy/scipy,",prio-normal,defect,Migrated from Trac,scipy.special",Programming,single,The bug caused by use dedicated npy_intp instead of int to store memory offset in NI_Label,Data type error,the bug occurred at an assignment,Within function,Assignment,PyErr_NoMemory,"foreign, PyErr_NoMemory",Exception Handling,c to py,Data Corruption,The fitx change nyp_intp to int,Within function,assignment,detection challenge for this bug lies in identifying type discrepancies between languages when handling memory offsets.,,
79d960f807e3b304833a88347e08de17226343ac,scipy/scipy,",prio-normal,defect,Migrated from Trac",Programming,single,The bug caused by data type misuse,Data type error,the bug occurred at assignment,Within function,function call,Py_BuildValue,"foreign, Py_BuildValue",Parsing arguments and building values,py to c,Unexpected Behavior,The fitx add some new functions,Within function,whole function,detection challenge to identify the bug caused by data type misuse is the inconsistency in type handling across different languages.,,
9ceaa72ebe96cb5423aa3fb2adede3fcd1c7b6b0,python/cpython,",bug",Programming,single,"The bug caused by the incorrect handling of restartable signals on BSD systems, such as NetBSD 2.0 and FreeBSD 4.8. The code was not correctly disabling these signals.",compatibility,The bug was  to occur in the initsigs() function where the signal() function was originally used for signal handling.,Within function,Cross-language API call site,PyOS_setsig,"foreign, PyOS_setsig",Operating System Utilities,c to py,Unexpected Behavior,"This change was made for handling SIGPIPE, SIGXFZ, and SIGXFSZ signals.",Within function,Cross-language API call site,The challenge in detecting this bug in a multi-language project would be understanding the nuances of signal handling across different languages and platforms.,,
78d7ab3d0c35cb8aa0cdf449e0db1472e6ad60dc,numpy/numpy,",00 - Bug,04 - Documentation,component: numpy.core",other,single,The bug caused by skipping the setting of docstrings if the docstring is identical,other,The bug was occrred at cross-language API,Within function,Cross-language API call site,PyErr_Occurred,"foreign, PyErr_Occurred",Exception Handling,c to py,Unexpected Behavior,The bug change many if structure,Within function,if structure,detection challenge to detect identical docstrings across different programming languages.,,
a19cdad6dc2815f6044c56601e8dd81d9c219631,python/cpython,",bug",other,single,install script repairing,other,The bu occurred at cross-anguage API,Within function,Cross-language API call site,PyImport_ImportModule,"foreign, PyImport_ImportModule",Importing Modules,c to py,Unexpected Behavior,"There's a typo fix (build->built), and changes so that --target-version can still work, even when the distribution has extension modules.",Within function,Cross-language API call site,The challenge in detecting this bug in a multi-language project lies in its specificity to Python's build,,
4a2b6a7d8e389abe06d5d7f2fbfa6ebd03b9092a,numpy/numpy,",00 - Bug,component: numpy.random",Security,single,The bug is caused by the function log(0.0) which produces inf or nan values when generating random values.,divided by 0,The bug  to occur in the part of the code where the log(0.0) function was called during random number generation.,Within function,Conditional (predicate/conditional expression),rk_double,"helper, rk_double",Objects,c to py,Unexpected Behavior,The bug was fixed by ensuring that log(0.0) doesn't produce inf or nan values when generating random values.,Within function,Conditionals (predicate/conditional expression),The challenge in detecting this bug in a multi-language project lies in special case,,
d7a73f8c700edcf150d59a570e0173b60f84c7a7,numpy/numpy,",00 - Bug,component: build",Programming,single,The bug was caused by the use of the system() function for AVX detection on MacOS.,compatibility,The bug occur in the cpu_supports_avx() and using_mavericks() functions where the system() function was originally used.,Outside function,Preprocessor Directives,sysctlbyname,"helper, sysctlbyname",Objects,c to py,Unexpected Behavior,The bug was fixed by replacing the system() function with a direct C call to sysctlbyname().,Within function,whole function,The challenge in detecting this bug lies in the fact that it's a platform-specific issue (MacOS) and involves low-level system interactions.,,
6f3fca81fd7074012b291d86f33bdf42719999f3,numpy/numpy,",00 - Bug,component: numpy.core",Programming,single,The bug is caused by the fact that pip can leave old pieces of previous versions of numpy around when installing a newer version.,compatibility,"The bug was not a runtime error, so it doesn't occur at a specific location in the code. ",Outside function,Outside any function/global area,"Py_VISIT, Py_CLEAR","foreign, Py_VISIT","Supporting Cyclic Garbage Collection, memory management",c to py,Unexpected Behavior,The bug is fixed by raising an ImportError if the wrong multiarray or umath module is detected.,Within function,whole function,"The challenge in identifying this bug lies in the fact that it only manifests when an older version of the module is present in the system, which can be overlooked in environments where the latest versions of all modules are assumed. ",,
825f8f8ca06442ce2abb1ec5718c7d826c84dacb,DinoTools/dionaea,,Programming,single,The bug was caused by the fact that the setgroups function was not called before setresuid. This could potentially allow privileged groups to retain their privileges even after a user's privileges have been dropped.,permission,The bug occur at the point where setresuid was called before setgroups,Within function,Function call,signal,"foreign, signal",Set handlers for asynchronous events,c to py,Unexpected Output,The bug was fixed by calling setgroups before setresuid. This ensures that any privileged groups are dropped before the user's privileges are dropped.,Within function,Function call,"the challenge in detecting this bug lies in understanding the nuances of system calls and their order of execution, especially when dealing with user and group permissions.",,
968b588009881e27bc61e35efbe49ebff7f1093e,DinoTools/dionaea,,Programming,single,The bug was caused by incorrect boundary check condition.,special case,"the bug occurred after a if structure which mwassed a condition, in a assiment",Within function,True/false branch,signal,"foreign, signal",Set handlers for asynchronous events,c to py,Unexpected Output,The bug can be fixed by adding a if branch,Within function,True/false branch," In a multi-language project, such bugs can be particularly challenging to detect due to the complexity of interactions between different parts of the codebase, each potentially written in a different language.",,
bb988fb9bf563a790d6055e4f98addd782e42677,tskit-dev/tskit,,Programming,single,"The function raise_hdf5_format_error can be called on either a path or a file object, but it assumes the input is a path. This causes an issue when trying to open a file object as a path",error handling,The bug occurs in the rawase_hdf5_format_error function in the formats.py file when it tries to open the file object as if it were a path.,Within function,function call,PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,type error,The bug was fixed by adding an additional branch for error handling.,Within function,Exceptional block,"t can be challenging to ensure that all functions correctly handle different types of inputs, especially when those inputs can be different types of objects.",,
edbaaca4c3c0c09ed270a81e0818138db776101d,tskit-dev/tskit,,Security,single,The bug was caused by an incorrect memory allocation size for the node stack in the tree traversal functions. The size was not sufficient when the virtual root was supplied as the root argument to the Tree.nodes method.,Memory allocations/releasing,The bug occur in the tree traversal functions tsk_tree_preorder and tsk_tree_postorder where the node stack was allocated,Within function,Function call,PyDataMem_NEW,"helper, PyDataMem_NEW",Memory management,c to py,Crash,The bug was fixed by introducing a new function tsk_tree_get_size_bound that provides a safe upper bound for the number of nodes in the tree. This function is used to correctly allocate memory for the node stack in the tree traversal functions.,Within function,Function call,The main challenge in detecting this bug is understanding the complex logic of tree traversal and memory allocation in the context of a multi-language project. The bug is subtle and requires a deep understanding of the project's memory management and tree traversal logic.,,
568a9a953d549ae9a48f0f6d98435249841b7b5e,tskit-dev/tskit,,Security,single,"The bug is caused by an underestimation of the buffer size required for the get_newick function in the C code. When the function is called with a large effective population size (Ne), the buffer size allocated is insufficient",buffer overflow,"The bug occur in the get_newick function in the C code. Specifically, the error happens when the function tsk_convert_newick was called with an insufficient buffer size.",Within function,function call,PyArg_ParseTupleAndKeywords,"foreign, PyArg_ParseTupleAndKeywords",Parsing arguments,py to c,LibraryError,"The bug is fixed by adjusting the buffer size calculation in the get_newick function. The buffer size is now computed as an upper bound based on the number of nodes and the precision, with an additional safety margin added. The buffer size is also checked to ensure it is greater than 0 before memory allocation.",Within function,function call,the challenge in detecting this bug lies in the interaction between Python and C code. The bug manifests when a Python function calls a C function with an underestimated buffer size.,,
ce5b3c3188ec655ece4428e6a3e1622e322f4603,facebookincubator/cinder,,Performance,single,The bug is caused by increse a non-NULL value using Py_XINCREF,API misuse,"The bug was not a runtime error, so it doesn't occur at a specific location in the code.",Outside function,Outside any function/global area,Py_XINCREF,"foreign, Py_XINCREF",Memory management,c to py,Performance issue,The bug is fixed by changing inappropriate API function,Within function,function call,"The challenge in detecting this bug lies in the fact that it involves the misuse of function arguments, which may not be immediately obvious without a thorough understanding of the expected behavior of the functions.",,
779da3cd4ed1343475812938002abc2306115af8,pyodide/pyodide,,Security,single,"The bug is caused by the use of TextDecoder on a part of the Wasm HEAP, when using WebAssembly.instantiate later on",buffer overflow,The bug occur at the line: var jsval = new TextDecoder('utf-8').decode(bytes);,Within function,instantiate object,"PyUnicode_KIND, PyErr_SetString","foreign, PyUnicode_KIND, PyErr_SetString","Objects, Exception Handling",c to py,Crash,The bug is fixed by rewriting the function to avoid using the decoder.,Within function,whole function,"The main challenge in detecting this bug is understanding the complex interactions between different parts of the code, specifically the use of TextDecoder on the Wasm HEAP and the subsequent use of WebAssembly.instantiate. This requires a deep understanding of both the specific functions being used and the broader context in which they are used.",,
94070b88261ff1afc0fd7bb700a8f8ccaffa1889,sagemath/sage,,Programming,single,"The original code was if ( _signals.mpio && 1 ) {, which is not correct. The logical AND operation (&&) with 1 doesn't make sense in this context.",logic error,The bug occured in if conditional,Within function,Conditional (predicate/conditional expression),PyErr_SetString,"foreign, PyErr_SetString",Exception Handling,c to py,Unexpected Output,The bug was fixed by replacing the logical AND operation (&&) with a bitwise AND operation (&).,Within function,Conditionals (predicate/conditional expression),"the challenge in detecting this bug lies in understanding the context and semantics of the code. The logical error is subtle and may not cause an immediate failure or crash, but could lead to unexpected behavior during runtime.",,
065d658eb5fc6eca608ce9cdbbeb21d98cdfd495,rogerbinns/apsw,,Programming,single,The bug was caused by the Global Interpreter Lock (GIL) not being acquired during the function free operation.,API misuse,"The bug was not a runtime error, so it doesn't occur at a specific location in the code.",Outside function,Outside any function/global area,PyGILState_Ensure,"foreign, PyGILState_Ensure","Initialization, Finalization, and Threads",c to py,DeadLock,The bug was fixed by acquiring the GIL before manipulating Python objects and releasing it afterwards.,Within function,function call,"The main challenge in detecting this bug is understanding the interaction between the C code and the Python interpreter, particularly the requirement to hold the GIL when manipulating Python objects.",,
6f6a7921d68d4b4d52716bcbf3ce28edb7f43ee7,rogerbinns/apsw,,Programming,single,"The bug is caused by the lack of a call to PyUnicode_READY in the Python 3 version of the APSW (Another Python SQLite Wrapper) library. This causes the count method to return incorrect results until the string is printed, which internally calls PyUnicode_READY.",API misuse,The bug occur in the convertutf8stringsize and getutf8string functions in the APSW library where the APSW_Unicode_Return macro was used.,Within function,function call,PyUnicode_AS_UNICODE,"foreign, PyUnicode_AS_UNICODE",Objects,c to py,Unexpected Output,The bug is fixed by modifying the APSW_Unicode_Return macro to call PyUnicode_READY before returning the string,Within function,function call,"The main challenge in detecting this bug is understanding the nuances of the Python C API, specifically the need to call PyUnicode_READY on strings before they are used.",,
efea9dc4dd8aaaffc6e8134848c7abb03bfd0467,rogerbinns/apsw,,Programming,single,"The bug was caused by a failure in the commit operation in the context manager, which could occur under certain conditions (e.g., when a transaction is buffered in memory and the commit operation encounters a busy error).",Error Handling,"the bug occurred in the Connection_exit function, specifically in the part where the commit operation function sqlite3_mprintf.",Within function,function call,Py_XDECREF,"foreign, Py_XDECREF",Memory management,c to py,Unexpected Output,"The bug was fixed by changing the error handling logic in the Connection_exit function. Specifically, the commit operation was attempted first, and if it failed, a rollback operation was performed.",Within function,function call,"The main challenge in detecting this bug in a multi-language project would be understanding the specific behavior and error handling mechanisms of the database operations in the context of the language in use. In this case, the bug is related to the specific behavior of commit operations in SQLite, which might not be immediately obvious if the developer is not familiar with this specific database technology.",,
9d9549e819906f2369b16ac081bc726d405685e0,rogerbinns/apsw,,Performance,single,"The bug is caused by writing the typedef in function. If you define a type inside a function, that type will be defined each time the function is called.",resource,the bug occurred in a function which having struct declarations.,Within function,struct declarations,PyModule_AddObject,"foreign, PyModule_AddObject",Objects,c to py,Performance issue,The bug is fixed by moving struct declaration outside the function,Outside function,struct declarations,The main challenge in detecting this bug is understanding the efficient way to declare the struct,,
d03f41559a17dacf3bb8418c306699b70305f2af,rogerbinns/apsw,,Programming,single,The bug is caused by the use of outdated SQLite functions in the APSW (Another Python SQLite Wrapper) project. The project should be updated to use the newer version 2 functions where applicable.,API misuse,the bug occurred in the outdated SQLite functions are used,Within function,function call,PyType_Ready,"foreign, PyType_Ready",Objects,c to py,Unexpected Output,The bug can be fixed by replacing the outdated SQLite functions with their version 2 counterparts in the src/apsw.c file. This would involve updating the function calls and any necessary parameters or return values.,Within function,function call,the challenge in detecting this bug lies in the need to understand the evolution of the SQLite API and how it's used in different parts of the APSW project.,,
d8c092816ab6b611692d992cbfaf882a10424793,numpy/numpy,",00 - Bug,component: Other",Programming,single,The bug was caused by incorrect boundary check condition.,special case,"the bug occurred after a if structure which mwassed a condition, in a assiment",Within function,Assignment,"PyErr_SetString, Py_DECREF ","foreign, PyErr_SetString, Py_DECREF ","Exception Handling, Memory management",c to py,Crash,The bug can be fixed by adding a if branch,Within function,True/false branch," In a multi-language project, such bugs can be particularly challenging to detect due to the complexity of interactions between different parts of the codebase, each potentially written in a different language.",,
c2e2a6d5da55d1c3cf39be26839313700d5e3dce,robclewley/pydstool,,Programming,single,"The bug was caused by the removal of the numarray module in Numpy version 1.9 and later. The code was trying to import and use the get_numarray_include() function from numarray, which no longer exists.",Compatibility,he bug occur at the line where the code tries to import and use the get_numarray_include() function from numarray.,Outside function,function/variable declarations,Py_INCREF,"foreign, Py_INCREF",Memory management,c to py,ImportError,The bug was fixed by removing the import and use of the get_numarray_include() function from numarray.,Outside function,function/variable declarations,"The main challenge in detecting this bug is understanding the changes and updates in the dependencies of the project. In this case, the removal of the numarray module in newer versions of Numpy.",,
